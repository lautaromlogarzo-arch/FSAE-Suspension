<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LL - Dynamic Performance Systems</title>
    <link rel="icon" href="./logo_transparente1.png?v=3" type="image/png">

    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>

    <style>
        :root { 
            --primary: #d62828; 
            --dark: #003049; 
            --light: #fdf0d5; 
            --accent: #669bbc; 
            --chassis: #7f8c8d; 
            --fea: #9b59b6; 
            /* Google Tabs Style Vars */
            --google-blue: #1a73e8;
            --google-text: #5f6368;
            --google-bg: #fff;
        }
        
        body { 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            margin: 0; 
            padding: 0; 
            background: #edf2f4; 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden; 
        }

        /* --- NUEVO: BRAND HEADER (LOGES) --- */
        .brand-bar {
            background: var(--dark);
            color: #fff;
            padding: 4px 24px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            border-bottom: 4px solid var(--primary);
            z-index: 101;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .brand-title {
            font-family: 'Segoe UI', sans-serif;
            font-weight: 900;
            font-size: 1.8rem;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin: 0;
            background: linear-gradient(90deg, #fff, #ddd);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .brand-logo {
           height: 75px; /* Ajusta la altura del logo */
            margin-right: 15px; /* Espacio entre el logo y el texto */
            width: auto;
        }

        /* --- GOOGLE STYLE TABS HEADER --- */
        .google-header {
            background: var(--google-bg);
            border-bottom: 1px solid #ddd;
            display: flex;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            z-index: 100;
            height: 48px;
            flex-shrink: 0;
            overflow-x: auto; 
        }

        .g-tab {
            display: flex;
            align-items: center;
            padding: 0 24px;
            color: var(--google-text);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            position: relative;
            text-transform: uppercase;
            transition: background 0.2s;
            white-space: nowrap;
            height: 100%;
        }

        .g-tab:hover {
            background: #f1f3f4;
            color: #202124;
        }

        .g-tab.active {
            color: var(--google-blue);
        }

        .g-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--google-blue);
            border-radius: 3px 3px 0 0;
        }

        /* --- APP CONTAINERS (MODIFICADO) --- */
        #app-container-v5, 
        #app-container-steering, 
        #app-container-fatigue, 
        #app-container-brakes, 
        #app-container-damper {
            display: none; 
            flex: 1;
            height: calc(100vh - 48px - 55px);
            overflow: hidden;
            background: #f8f9fa;
            padding: 20px;
            box-sizing: border-box;
            flex-direction: row;
            gap: 20px;
        }
    
        #app-container-v5 { display: flex; }

        /* --- PANELES LATERALES UNIFICADOS --- */
        .sidebar, 
        .steering-panel, 
        .fatigue-panel, 
        .brake-panel, 
        .damper-panel {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            flex: 0 0 450px; /* Ancho fijo */
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Scroll habilitado */
            height: 100%;
            border-left: 4px solid var(--accent);
            box-sizing: border-box;
        }

        /* COLORES ESPECÍFICOS */
        .sidebar { border-left-color: var(--primary); }
        .fatigue-panel { border-left-color: #e67e22; }
        .brake-panel { border-left-color: #27ae60; }
        .damper-panel { border-left-color: #8e44ad; }

        /* PANEL DE RESULTADOS VISUALES */
        .st-output-container {
            flex: 2;
            overflow-y: auto;
            padding: 0 10px;
            font-family: 'Segoe UI', sans-serif; 
        }

        .st-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            margin-bottom: 20px;
            border: 1px solid #eaeaea;
        }

        .st-card h3 {
            color: var(--dark);
            border-bottom: 2px solid var(--accent);
            padding-bottom: 8px;
            margin-top: 0;
            font-size: 1.1rem;
        }

        /* Grid para mostrar datos clave (Torques, Angulos) */
        .st-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .st-stat-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #ddd;
        }
        
        .st-stat-box.highlight { border-left-color: var(--primary); background: #fff5f5; }
        .st-stat-box.info { border-left-color: var(--google-blue); background: #f0f8ff; }
        .st-stat-box.success { border-left-color: #27ae60; background: #eafaf1; }
        .st-stat-box.warning { border-left-color: #f39c12; background: #fef9e7; }
        .st-stat-box.danger { border-left-color: #c0392b; background: #fdedec; }

        .st-stat-label {
            display: block;
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .st-stat-value {
            display: block;
            font-size: 1.1rem;
            font-weight: 700;
            color: #2c3e50;
        }

        .st-unit { font-size: 0.8rem; font-weight: normal; color: #888; }

        /* Estilos de Tabla mejorada */
        .st-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            margin-top: 10px;
        }

        .st-table th {
            background: #f1f3f4;
            color: #444;
            font-weight: 600;
            text-align: center;
            padding: 10px;
            border-bottom: 2px solid #ddd;
        }

        .st-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            color: #333;
        }

        .st-table tr:hover { background-color: #f9f9f9; }

        /* Etiquetas (Badges) */
        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 5px;
        }

        .badge-confort { background-color: #e6fffa; color: #00b894; border: 1px solid #b2f5ea; }
        .badge-optimo { background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }
        .badge-safe { background-color: #eafaf1; color: #27ae60; border: 1px solid #abebc6; }
        .badge-danger { background-color: #fdedec; color: #c0392b; border: 1px solid #fadbd8; }
        .badge-warning { background-color: #fef9e7; color: #f39c12; border: 1px solid #f9e79f; }

        /* Inputs Generales */
        .st-header { color: var(--dark); border-bottom: 2px solid #eee; margin-bottom: 15px; padding-bottom: 5px; font-size: 1.1rem; font-weight: 700; text-transform: uppercase; }
        .st-sub-header { color: var(--google-blue); font-size: 0.9rem; font-weight: 700; margin-top: 15px; margin-bottom: 8px; text-transform: uppercase; }
        
        .st-row { display: flex; align-items: center; margin-bottom: 6px; border-bottom: 1px solid #f1f1f1; padding-bottom: 2px; }
        .st-row label { flex: 2; font-size: 0.85rem; color: #444; font-weight: 600; }
        .st-row input { flex: 1; padding: 4px; border: 1px solid #ccc; border-radius: 4px; text-align: right; font-family: monospace; font-weight: bold; color: var(--primary); }
        
        .st-btn { background: var(--google-blue); color: white; border: none; padding: 12px; width: 100%; border-radius: 4px; font-weight: bold; font-size: 1rem; cursor: pointer; margin-top: 20px; box-shadow: 0 2px 4px rgba(26, 115, 232, 0.3); }
        .st-btn:hover { background: #1557b0; }
        .fatigue-btn { background: #e67e22; }
        .fatigue-btn:hover { background: #d35400; }
        .brake-btn { background: #27ae60; }
        .brake-btn:hover { background: #1e8449; }

        .damper-panel { border-left: 4px solid #8e44ad; }
        .damper-btn { background: #8e44ad; }
        .damper-btn:hover { background: #732d91; }


        /* --- ESTILOS ORIGINALES (V5) --- */
        .sidebar { width: 450px; background: #fff; overflow-y: auto; padding: 20px; box-shadow: 4px 0 15px rgba(0,0,0,0.1); z-index: 10; display: flex; flex-direction: column; border-right: 1px solid #ddd; }
        .main-content { flex: 1; display: flex; flex-direction: column; position: relative; }
        .viz-container { flex: 1; position: relative; background: #dae3e7; }
        .results-panel { height: 400px; background: var(--dark); color: #eee; overflow-y: auto; padding: 15px 25px; font-family: 'Consolas', monospace; font-size: 0.85rem; border-top: 4px solid var(--primary); }
        h2 { color: var(--dark); border-bottom: 3px solid var(--primary); padding-bottom: 10px; margin-bottom: 15px; font-size: 1.2rem; text-transform: uppercase; }
        h3 { margin-top: 0; margin-bottom: 10px; font-size: 1rem; color: #fff; border-bottom: 1px solid #555; padding-bottom: 5px; }
        h4 { margin: 12px 0 5px 0; color: var(--accent); font-size: 0.85rem; text-transform: uppercase; border-bottom: 1px solid #eee; padding-bottom: 2px; }
        .section-header { font-weight: bold; color: var(--dark); margin-top: 15px; margin-bottom: 5px; display: block; font-size: 0.95em; background: #f0f4f8; padding: 5px; border-radius: 4px; }
        .input-group { background: #f8f9fa; padding: 8px; border-radius: 6px; border: 1px solid #e9ecef; margin-bottom: 8px; }
        .row { display: flex; gap: 8px; align-items: center; margin-bottom: 4px; }
        .row label { flex: 1.6; font-size: 0.8rem; font-weight: 600; color: #444; }
        .row input, .row select { flex: 1; padding: 4px 6px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.85rem; }
        .row input[type="color"] { padding: 0; height: 25px; }
        .coord-inputs { display: flex; gap: 2px; flex: 2; }
        .coord-inputs input { width: 100%; text-align: center; font-family: monospace; font-weight: 500; font-size: 0.8rem; }
        .calc-button { width: 100%; padding: 12px; background: var(--primary); color: white; border: none; cursor: pointer; font-size: 1rem; font-weight: 800; border-radius: 6px; margin-top: 15px; box-shadow: 0 4px 6px rgba(214, 40, 40, 0.3); }
        .calc-button:hover { background: #b51717; transform: translateY(-1px); }
        .tabs { display: flex; background: #e9ecef; border-radius: 6px; padding: 3px; margin-bottom: 15px; }
        .tab { flex: 1; text-align: center; padding: 8px; cursor: pointer; font-weight: 700; color: #666; border-radius: 4px; transition: 0.2s; font-size: 0.8rem; }
        .tab.active { background: white; color: var(--primary); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        table { width: 100%; border-collapse: separate; border-spacing: 0; margin-top: 5px; margin-bottom: 15px; }
        th { text-align: left; color: #a8dadc; border-bottom: 2px solid #457b9d; padding: 5px; font-weight: 600; font-size: 0.8rem; letter-spacing: 0.5px; }
        td { padding: 5px; border-bottom: 1px solid #365b77; color: #f7f4f4; }
        .danger { color: #ff4d4d; font-weight: bold; } 
        .warning { color: #ffd166; font-weight: bold; } 
        .ok { color: #06d6a0; font-weight: bold; }
        .vector-cell { color: #a8dadc; font-family: 'Consolas', monospace; font-weight: bold; }
        .tire-inputs input { text-align: center; font-weight: bold; color: var(--dark); }
        .cb-label { display: flex; align-items: center; cursor: pointer; font-weight: bold; color: var(--primary); font-size: 0.9rem;}
        .note { font-size: 0.75rem; color: #aaa; margin-top: 4px; font-style: italic; }
        .result-block { margin-bottom: 20px; padding-bottom: 10px; text-align: center; }
        .result-block h3 { margin: 6px 0 8px; text-align: center; }
        .result-block table { margin: 0 auto; width: auto; }
        .result-block table th, .result-block table td { text-align: center; padding: 6px 10px; }
        /* --- RESPONSIVE DESIGN (CELULARES) --- */
        @media screen and (max-width: 768px) {
            /* 1. Cambiar la orientación a Columna (uno arriba del otro) */
            #app-container-v5, 
            #app-container-steering, 
            #app-container-fatigue, 
            #app-container-brakes {
                flex-direction: column;
                height: auto; /* Permitir scroll natural */
                overflow-y: auto;
            }

            /* 2. Ajustar barra lateral para que ocupe todo el ancho */
            .sidebar, 
            .steering-panel, 
            .fatigue-panel, 
            .brake-panel {
                width: 100%;
                max-width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 4px solid #ddd; /* Separación visual */
                flex: none;
                padding-bottom: 30px;
            }

            /* 3. Ajustar el contenido principal */
            .main-content, 
            .st-output-container {
                width: 100%;
                flex: none;
                height: auto;
                padding: 10px;
            }

            /* 4. Asegurar que los gráficos 3D tengan altura en celular */
            .viz-container, #brake-viz-container {
                height: 400px; 
                width: 100%;
            }

            /* 5. Ajustar Header y Logo para pantallas chicas */
            .brand-bar {
                padding: 10px 15px;
            }
            .brand-title {
                font-size: 1.1rem; /* Letra más chica */
                line-height: 1.2;
            }
            .brand-logo {
                height: 45px; /* Logo más chico */
                margin-right: 10px;
            }
            
            /* 6. Ajustar Scroll del menú de pestañas */
            .google-header {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
        }
    </style>
</head>
<body>

    <div class="brand-bar">
        <img src="logo_transparente3.png" alt="LPS Logo" class="brand-logo">
        <h1 class="brand-title">LAUTARO LOGARZO - DYNAMIC PERFORMANCE SYSTEMS</h1>
    </div>

    <div class="google-header">
        <div class="g-tab active" onclick="showApp('v5', this)">Esfuerzos en barras y portamaza</div>
        <div class="g-tab" onclick="showApp('steering', this)">Dirección (Rack & Pinion)</div>
        <div class="g-tab" onclick="showApp('fatigue', this)">Cálculo de fatiga en la masa</div>
        <div class="g-tab" onclick="showApp('brakes', this)">Dimensionamiento de frenos</div>
        <div class="g-tab" onclick="showApp('damper', this)">Dimensionamiento de amortiguación</div>
    </div>

    <div id="app-container-v5">
        <div class="sidebar">
            <h2>Simulador Suspensión FSAE</h2>

            <div class="input-group" style="background: #e3f2fd; border-color: #bbdefb;">
                <div class="row">
                    <label>VISTA 3D:</label>
                    <select id="viewMode" onchange="calculateAndPlot()" style="font-weight:bold; flex:2;">
                        <option value="full">Vehículo Completo (4 Ruedas)</option>
                        <option value="both">Solo Suspensión (Izq. D+T)</option>
                        <option value="front" selected>Solo Delantera (Izq.)</option>
                        <option value="rear">Solo Trasera (Izq.)</option>
                    </select>
                </div>
            </div>

            <div class="tabs">
                <div class="tab active" onclick="switchTab('front')">Delantera (L)</div>
                <div class="tab" onclick="switchTab('rear')">Trasera (L)</div>
            </div>
            <div id="active-inputs-container" class="input-group"></div>

            <span class="section-header">PARÁMETROS DEL VEHÍCULO</span>
            <div class="input-group">
                <h4>Dinámica</h4>
                <div class="row"><label>G Frenado:</label><input type="number" id="g_braking" value="1.7" step="0.1"></div>
                <div class="row"><label>G Aceleración:</label><input type="number" id="g_accel" value="1.2" step="0.1"></div>
                <div class="row"><label>G Lateral:</label><input type="number" id="g_cornering" value="2.0" step="0.1"></div>
                <div class="row"><label>G Bump:</label><input type="number" id="g_bump" value="3.0" step="0.1"></div>
                <div class="row"><label>Mu Lng/Lat:</label><div class="coord-inputs"><input type="number" id="mu_long" value="1.0" step="0.1"><input type="number" id="mu_lat" value="1.0" step="0.1"></div></div>

                <h4>Dimensiones y Masa</h4>
                <div class="row"><label>Wheelbase (mm):</label><input type="number" id="wheelbase" value="1650"></div>
                <div class="row"><label>Trocha Del. (mm):</label><input type="number" id="track_front" value="1200"></div>
                <div class="row"><label>Altura CG (mm):</label><input type="number" id="cg_height" value="350"></div>
                <div class="row"><label>Masa Total (kg):</label><input type="number" id="m_total" value="365"></div>
                <div class="row"><label>% Peso Frontal:</label><input type="number" id="weight_dist_front" value="0.4" step="0.01"></div>
                <div class="row"><label>No Susp. (D/T):</label><div class="coord-inputs"><input type="number" id="unsprung_f" value="28"><input type="number" id="unsprung_r" value="28"></div></div>
            </div>

            <span class="section-header">DATOS FEA (FRENO)</span>
            <div class="input-group" style="border-left:4px solid var(--fea);">
                <div class="row"><label>Torque Freno (Nm):</label><input type="number" id="fea_brake_torque" value="320.0"></div>
                <div class="row"><label>Radio Montaje (mm):</label><input type="number" id="fea_mount_radius" value="80.0"></div>
                <div class="row"><label>Orejas Caliper:</label><input type="number" id="fea_ears" value="2"></div>
            </div>

            <span class="section-header">RUEDAS Y MATERIALES</span>
            <div class="input-group">
                <h4>Neumático y Llanta</h4>
                <div class="row"><label>Medida:</label>
                    <div class="coord-inputs tire-inputs">
                        <input type="number" id="tire_w_inp" value="175"><span style="padding:4px; font-weight:bold;">/</span>
                        <input type="number" id="tire_ar_inp" value="50"><span style="padding:4px; font-weight:bold;">R</span>
                        <input type="number" id="rim_d_inp" value="13"></div></div>
                <div class="row"><label style="color:var(--primary); font-weight:bold;">Offset (mm):</label>
                    <input type="number" id="wheel_offset" value="45" style="border: 2px solid var(--primary); font-weight:bold;"></div>
                
                <div class="row" style="margin-top:8px; background:#eee; padding:5px; border-radius:4px;">
                    <label class="cb-label" for="transparent_tires">
                        <input type="checkbox" id="transparent_tires" onchange="calculateAndPlot()">Ruedas Transparentes
                    </label>
                </div>

                <h4>Tubos & Colores (Negativo=Compresión)</h4>
                <div class="row"><label>Sy(MPa)/E(GPa):</label><div class="coord-inputs"><input type="number" id="mat_yield" value="310"><input type="number" id="mat_E" value="210"></div></div>
                <div class="row"><label>OD/ID (mm):</label><div class="coord-inputs"><input type="number" id="tube_od" value="20"><input type="number" id="tube_id" value="0"></div></div>
                <div class="row"><label>FS Objetivo:</label><input type="number" id="sf_target" value="3.5" step="0.1"></div>
                <div class="row"><label>Comp. / Trac.:</label><div class="coord-inputs"><input type="color" id="color_comp" value="#ff0000"><input type="color" id="color_tens" value="#0088ff"></div></div>
                <div class="note">Convención: Fuerza Negativa (-) = Compresión</div>
            </div>

            <span class="section-header">TRANSMISIÓN (Trasera)</span>
            <div class="input-group">
                <div class="row"><label>Torque Motor (Nm):</label><input type="number" id="eng_torque" value="120"></div>
                <div class="row"><label>Relación / Efic.:</label><div class="coord-inputs"><input type="number" id="gear_ratio" value="4.0"><input type="number" id="drivetrain_eff" value="0.95" step="0.01"></div></div>
                <div class="row"><label>Palier OD/ID:</label><div class="coord-inputs"><input type="number" id="palier_od" value="22.0"><input type="number" id="palier_id" value="0.0"></div></div>
                <div class="row"><label>Sy Material (MPa):</label><input type="number" id="palier_sy" value="900"></div>
            </div>

            <button class="calc-button" onclick="calculateAndPlot()">⚡ ACTUALIZAR SIMULACIÓN</button>
            <br><br>
        </div>

        <div class="main-content">
            <div id="plot3d" class="viz-container"></div>
            <div class="results-panel">
                <div id="results-output" style="text-align:center; color:#aaa;">Cargando...</div>
                <div id="fea-report-container"></div>
            </div>
        </div>
    </div>

    <div id="app-container-steering">
        <div class="steering-panel">
            <h2 class="st-header">Cálculo de Dirección FSAE</h2>
            
            <div class="st-sub-header">1. Inputs Geometría (Tabla)</div>
            <div class="st-row"><label>Giro Volante (°):</label><input type="number" id="st_giro_vol" value="135.0"></div>
            <div class="st-row"><label>Giro Rueda (°):</label><input type="number" id="st_giro_rueda" value="35.0"></div>
            <div class="st-row"><label>Fuerza Objetivo (kg):</label><input type="number" id="st_obj_kg" value="15"></div>
            
            <div style="background:#f0f8ff; padding:5px; margin:5px 0; border-radius:4px;">
                <div class="st-row"><label>Masa (kg):</label><input type="number" id="st_g_masa" value="350.0"></div>
                <div class="st-row"><label>H CG (mm):</label><input type="number" id="st_g_hcg" value="350.0"></div>
                <div class="st-row"><label>Trocha (mm):</label><input type="number" id="st_g_trocha" value="1200.0"></div>
                <div class="st-row"><label>% Peso Front:</label><input type="number" id="st_g_pf" value="40.0"></div>
                <div class="st-row"><label>% LLTD Front:</label><input type="number" id="st_g_lltd" value="50.0"></div>
                <div class="st-row"><label>Caster (°):</label><input type="number" id="st_g_caster" value="8.0"></div>
                <div class="st-row"><label>KPI (°):</label><input type="number" id="st_g_kpi" value="9.0"></div>
                <div class="st-row"><label>Scrub Radius (mm):</label><input type="number" id="st_g_scrub" value="10.0"></div>
                <div class="st-row"><label>Pneu. Trail (mm):</label><input type="number" id="st_g_pneu" value="20.0"></div>
                <div class="st-row"><label>Mech. Trail (mm):</label><input type="number" id="st_g_mech" value="20.0"></div>
                <div class="st-row"><label>Steer Angle Calc (°):</label><input type="number" id="st_g_steer" value="20.0"></div>
                <div class="st-row"><label>G Lateral (g):</label><input type="number" id="st_g_glat" value="1.4"></div>
                <div class="st-row"><label>Diam. Volante (mm):</label><input type="number" id="st_g_diam" value="260.0"></div>
            </div>

            <div class="st-sub-header" style="border-top:2px solid #eee; padding-top:10px;">2. Inputs Esfuerzos (Detalle)</div>
            <div class="st-row"><label>Paso (mm):</label><input type="number" id="st_e_paso" value="10.0"></div>
            <div class="st-row"><label>Z Piñón:</label><input type="number" id="st_e_z" value="11"></div>
            <div class="st-row"><label>Brazo Mangueta (mm):</label><input type="number" id="st_e_brazo" value="75.1"></div>
            <div class="st-row"><label>Diam. Volante (mm):</label><input type="number" id="st_e_diam" value="260.0"></div>
            
            <div style="background:#fff0f0; padding:5px; margin:5px 0; border-radius:4px;">
                <div class="st-row"><label>Masa (kg):</label><input type="number" id="st_e_masa" value="350.0"></div>
                <div class="st-row"><label>H CG (mm):</label><input type="number" id="st_e_hcg" value="350.0"></div>
                <div class="st-row"><label>Trocha (mm):</label><input type="number" id="st_e_trocha" value="1200.0"></div>
                <div class="st-row"><label>Dist. Ejes (mm):</label><input type="number" id="st_e_wb" value="1650.0"></div>
                <div class="st-row"><label>% Peso Front:</label><input type="number" id="st_e_pf" value="40.0"></div>
                <div class="st-row"><label>% LLTD Front:</label><input type="number" id="st_e_lltd" value="50.0"></div>
                <div class="st-row"><label>Caster (°):</label><input type="number" id="st_e_caster" value="8.0"></div>
                <div class="st-row"><label>KPI (°):</label><input type="number" id="st_e_kpi" value="9.0"></div>
                <div class="st-row"><label>Scrub Radius (mm):</label><input type="number" id="st_e_scrub" value="10.0"></div>
                <div class="st-row"><label>Pneu. Trail (mm):</label><input type="number" id="st_e_pneu" value="20.0"></div>
                <div class="st-row"><label>Mech. Trail (mm):</label><input type="number" id="st_e_mech" value="20.0"></div>
                <div class="st-row"><label>Steer Angle (°):</label><input type="number" id="st_e_steer" value="20.0"></div>
                <div class="st-row"><label>G Lateral (g):</label><input type="number" id="st_e_glat" value="1.4"></div>
            </div>

            <div class="st-sub-header" style="border-top:2px solid #eee; padding-top:10px; color:#e67e22;">3. Datos Columna (Cardan)</div>
            
            <div class="st-row">
                <label>Ángulo Cruceta 1 (°):</label>
                <input type="number" id="st_u_angle1" value="15.0" placeholder="0">
            </div>
            <div class="st-row">
                <label>Ángulo Cruceta 2 (°):</label>
                <input type="number" id="st_u_angle2" value="0" placeholder="0">
            </div>

            <div style="background:#fff3e0; padding:5px; margin:5px 0; border-radius:4px; border:1px solid #ffe0b2;">
                <div style="font-size:0.75rem; color:#d35400; text-align:center; margin-bottom:4px; font-weight:bold;">DIMENSIONES CRUCETA (Para Fatiga)</div>
                <div class="st-row">
                    <label>Diam. Efectivo (mm):</label>
                    <input type="number" id="st_u_eff_diam" value="22.0">
                </div>
                <div class="st-row">
                    <label>Diam. Muñón (mm):</label>
                    <input type="number" id="st_u_pin_diam" value="9.0">
                </div>
            </div>

            <div class="st-sub-header" style="border-top:2px solid #eee; padding-top:10px; color:#8e44ad;">4. Dimensionamiento Piñón (AGMA)</div>
            
            <div class="st-row">
                <label>Ancho de Cara F (mm):</label>
                <input type="number" id="st_g_face" value="100">
            </div>

            <div style="background:#f3e5f5; padding:5px; border-radius:4px; margin-bottom:5px;">
                <div class="st-row">
                    <label>Dureza Brinell (HB):</label>
                    <input type="number" id="st_mat_hb" value="280" onchange="updateScFromHb()">
                </div>
                <div class="st-row">
                    <label>Resistencia Sup. Sc (MPa):</label>
                    <input type="number" id="st_mat_sc" value="550">
                </div>
                <div class="note" style="color:#8e44ad;">*Si ingresa HB, Sc se calcula solo (2.22*HB + 200).</div>
            </div>

            <div class="st-row">
                <label>Sy Piñón (MPa):</label>
                <input type="number" id="st_mat_sy_pinion" value="600">
            </div>

            <div class="st-sub-header" style="font-size:0.8rem; color:#666;">FACTORES AGMA</div>
            
            <div class="st-row">
                <label>Sobrecarga (Ko/Ka):</label>
                <input type="number" id="st_k_o" value="1.40" step="0.05">
            </div>
            <div class="note">Nota: Pianos/Baches -> 1.25 a 1.5</div>

            <div class="st-row">
                <label>Dinámico (Kv):</label>
                <input type="number" id="st_k_v" value="1.10" step="0.05">
            </div>
            <div class="note">Nota: Dir. Manual (Baja Vel) -> 1.05 a 1.1</div>

            <div class="st-row">
                <label>Montaje (Km):</label>
                <input type="number" id="st_k_m" value="1.20" step="0.05">
            </div>
            <div class="note">Nota: Montaje no perfecto -> 1.2</div>

            <button class="st-btn" onclick="runSteeringCalc()">CALCULAR DIRECCIÓN</button>
        </div>

        <div class="st-output-container" id="steering-output">
            <div style="text-align:center; margin-top:50px; color:#999;">
                <h3>Esperando cálculo...</h3>
                <p>Configura los inputs y presiona "CALCULAR DIRECCIÓN"</p>
            </div>
        </div>
    </div>

    <div id="app-container-fatigue">
        <div class="fatigue-panel">
            <h2 class="st-header" style="border-bottom-color: #e67e22;">Cálculo Fatiga Masa (Hub)</h2>
            
            <div class="st-sub-header" style="color:#e67e22;">Datos Generales</div>
            <div class="st-row"><label>Masa Auto (kg):</label><input type="number" id="fat_masa" value="365.0"></div>
            <div class="st-row"><label>Dist. Ejes (mm):</label><input type="number" id="fat_dist_ejes" value="1650"></div>
            <div class="st-row"><label>Trocha Del (mm):</label><input type="number" id="fat_trocha" value="1200"></div>
            <div class="st-row"><label>Altura CG (mm):</label><input type="number" id="fat_altura_cg" value="350"></div>
            <div class="st-row"><label>Reparto Adelante (0-1):</label><input type="number" id="fat_reparto" value="0.40" step="0.01"></div>
            
            <div class="st-sub-header" style="color:#e67e22;">Dinámica y G's</div>
            <div class="st-row"><label>G Frenado:</label><input type="number" id="fat_g_frenado" value="1.7"></div>
            <div class="st-row"><label>G Curva:</label><input type="number" id="fat_g_curva" value="2.0"></div>
            
            <div class="st-sub-header" style="color:#e67e22;">Geometría Masa</div>
            <div class="st-row"><label>Radio Llanta (mm):</label><input type="number" id="fat_radio_llanta" value="330.2"></div>
            <div class="st-row"><label>Offset Masa (mm):</label><input type="number" id="fat_offset" value="41.45"></div>
            <div class="st-row"><label>Mu Tire Long:</label><input type="number" id="fat_mu_long" value="1.4"></div>
            <div class="st-row"><label>Mu Tire Lat:</label><input type="number" id="fat_mu_lat" value="1.4"></div>

            <div class="st-sub-header" style="color:#e67e22;">MATERIAL</div>
            <div class="st-row"><label>Sy (MPa):</label><input type="number" id="fat_sy" value="390.0"></div>
            <div class="st-row"><label>Su (MPa):</label><input type="number" id="fat_su" value="480.0"></div>
            <div class="st-row"><label>E (MPa):</label><input type="number" id="fat_e" value="71000.0"></div>

            <div class="st-sub-header" style="color:#e67e22;">Geometría Muesca</div>
            <div class="st-row"><label>r (Radio mm):</label><input type="number" id="fat_r" value="3"></div>
            <div class="st-row"><label>d (Eje mm):</label><input type="number" id="fat_d" value="55"></div>
            <div class="st-row"><label>D (Resalte mm):</label><input type="number" id="fat_D" value="70"></div>

            <button class="st-btn fatigue-btn" onclick="runFatigueCalc()">CALCULAR FATIGA</button>
        </div>

        <div class="st-output-container" id="fatigue-output">
             <div style="text-align:center; margin-top:50px; color:#999;">
                <h3>Esperando cálculo...</h3>
                <p>Presiona "CALCULAR FATIGA" para ver el dashboard.</p>
            </div>
        </div>
    </div>

    <div id="app-container-brakes">
        <div class="brake-panel">
            <h2 class="st-header" style="border-bottom-color: #27ae60;">Dimensionamiento de Frenos</h2>
            
            <div class="st-sub-header" style="color:#27ae60;">1. Vehículo y Neumático</div>
            <div class="st-row"><label>Masa Total (kg):</label><input type="number" id="br_masa" value="360.0"></div>
            <div class="st-row"><label>Dist. Ejes (m):</label><input type="number" id="br_wb" value="1.65" step="0.01"></div>
            <div class="st-row"><label>Altura CG (m):</label><input type="number" id="br_hcg" value="0.350" step="0.005"></div>
            <div class="st-row"><label>Dist. Delantera (%):</label><input type="number" id="br_dist" value="0.40" step="0.01"></div>
            <div class="st-row"><label>Desaceleración (g):</label><input type="number" id="br_decel" value="1.6" step="0.1"></div>
            <div class="st-row"><label>Mu Neumático:</label><input type="number" id="br_mu" value="1.0" step="0.1"></div>
            <div class="st-row"><label>Downforce (N):</label><input type="number" id="br_df" value="0"></div>
            
            <div class="st-sub-header" style="color:#27ae60;">2. Datos Neumático (175/50 R13)</div>
            <div class="st-row"><label>Ancho (mm):</label><input type="number" id="br_tire_w" value="175"></div>
            <div class="st-row"><label>Perfil (%):</label><input type="number" id="br_tire_p" value="50"></div>
            <div class="st-row"><label>Llanta (in):</label><input type="number" id="br_rim" value="13"></div>

            <div class="st-sub-header" style="color:#27ae60;">3. Caliper y Pastilla</div>
            <div class="st-row"><label>Caras Fricción:</label><input type="number" id="br_faces" value="2"></div>
            <div class="st-row"><label>Radio Int (mm):</label><input type="number" id="br_ri" value="77.3"></div>
            <div class="st-row"><label>Radio Ext (mm):</label><input type="number" id="br_ro" value="102.7"></div>
            <div class="st-row"><label>Theta 1 (deg):</label><input type="number" id="br_t1" value="0"></div>
            <div class="st-row"><label>Theta 2 (deg):</label><input type="number" id="br_t2" value="60.0"></div>
            <div class="st-row"><label>Coef. Fricción (f):</label><input type="number" id="br_f" value="0.40"></div>

            <div class="st-sub-header" style="color:#27ae60;">4. Pedalera y Piloto</div>
            <div class="st-row"><label>Fuerza Piloto (kg):</label><input type="number" id="br_pilot" value="25"></div>
            <div class="st-row"><label>Pedal Ratio:</label><input type="number" id="br_pratio" value="5"></div>
            <div class="st-row"><label>Eficiencia:</label><input type="number" id="br_peff" value="0.9"></div>
            <div class="st-row"><label>Bias Delantero (0-1):</label><input type="number" id="br_bias" value="0.7"></div>

            <button class="st-btn brake-btn" onclick="runBrakeCalc()">CALCULAR FRENOS</button>
        </div>

        <div class="st-output-container" id="brake-output">
             <div style="text-align:center; margin-top:50px; color:#999;">
                <h3>Esperando cálculo...</h3>
                <p>Presiona "CALCULAR FRENOS" para ver el dimensionamiento.</p>
            </div>
        </div>
    </div>

    <div id="app-container-damper" style="display: none; flex-direction: row; gap: 25px; height: calc(100vh - 105px); padding: 20px; box-sizing: border-box;">
        <div class="damper-panel" style="flex: 0 0 480px; display: flex; flex-direction: column; background: #fff; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); overflow-y: auto; padding: 20px; border-left: 4px solid #8e44ad;">
            <h2 class="st-header" style="border-bottom-color: #8e44ad; margin-top:0;">Simulador Suspensión (Full Car)</h2>

            <div class="input-group" style="background: #f3e5f5; border: 1px solid #e1bee7; margin-bottom: 20px;">
                <div class="row">
                    <label style="color:#8e44ad;">MODO DE INPUT:</label>
                    <select id="damper_input_mode" onchange="toggleDamperInputs()" style="font-weight:bold; flex:2; color:#8e44ad;">
                        <option value="dist">Distancias (Brazos)</option>
                        <option value="coord" selected>Coordenadas 3D</option>
                    </select>
                </div>
                <div class="row" style="margin-top:5px; border-top:1px solid #e1bee7; padding-top:5px;">
                    <label style="color:#8e44ad;">VISTA 3D:</label>
                    <select id="damper_view_mode" onchange="runDamperCalc()" style="font-weight:bold; flex:2; color:#8e44ad;">
                        <option value="both" selected>Ambos Ejes</option>
                        <option value="front">Solo Delantera</option>
                        <option value="rear">Solo Trasera</option>
                    </select>
                </div>
            </div>

            <div class="st-sub-header" style="color:#8e44ad;">1. DATOS GLOBALES</div>
            
            <div class="st-row"><label>Masa Total (kg):</label><input type="number" id="gl_peso_total" value="350.0"></div>
            <div class="st-row"><label>Dist. Ejes (m):</label><input type="number" id="gl_wb" value="1.650"></div>
            <div class="st-row"><label>Dist. CG Del (m):</label><input type="number" id="gl_a" value="1.0"></div>
            <div class="st-row"><label>Altura CG (m):</label><input type="number" id="gl_hcg" value="0.35"></div>
            <div class="st-row"><label>Ancho Vía (m):</label><input type="number" id="gl_track" value="1.200"></div>
            <div class="st-row"><label>Downforce (N):</label><input type="number" id="gl_df" value="1000"></div>
            <div class="st-row"><label>% Aero Front:</label><input type="number" id="gl_aero_bal" value="0.45" step="0.01"></div>
            <div class="st-row"><label>G Lat / Long:</label>
                <div class="coord-inputs"><input type="number" id="gl_g_lat" value="1.5"><input type="number" id="gl_g_long" value="1.7"></div>
            </div>

            <div class="st-sub-header" style="color:#555; font-size:0.8rem;">CONFIGURACIÓN PISTA</div>
            <div class="st-row"><label>Vel. Auto (m/s):</label><input type="number" id="tr_v_car" value="15.0"></div>
            <div class="st-row"><label>Bache Alt/Lar (m):</label>
                <div class="coord-inputs"><input type="number" id="tr_h_bache" value="0.05" step="0.01"><input type="number" id="tr_l_bache" value="0.50" step="0.1"></div>
            </div>
            <div class="st-row"><label>Piano Alt/Pitch:</label>
                <div class="coord-inputs"><input type="number" id="tr_h_piano" value="0.04" step="0.01"><input type="number" id="tr_pitch" value="0.10" step="0.01"></div>
            </div>
            <div class="st-row"><label>Piano L.Diente:</label><input type="number" id="tr_l_diente" value="0.08" step="0.01"></div>

            <div class="st-sub-header" style="color:#2980b9; border-top: 2px solid #eee; padding-top:10px;">2. EJE DELANTERO</div>

            <div class="st-row"><label>Masa No Susp (Esq):</label><input type="number" id="fr_mu" value="16.0"></div>
            <div class="st-row"><label>K Tire (N/mm):</label><input type="number" id="fr_ktire" value="100.0"></div>
            <div class="st-row"><label>K Resorte (lbs/in):</label><input type="number" id="fr_kspring" value="300"></div>
            <div class="st-row"><label>L. Libre / Solido:</label>
                <div class="coord-inputs"><input type="number" id="fr_lfree" value="115"><input type="number" id="fr_lsolid" value="57"></div>
            </div>
            <div class="st-row"><label>Stroke / Preload:</label>
                <div class="coord-inputs">
                    <input type="number" id="fr_stroke" value="57" placeholder="Stroke">
                    <input type="number" id="fr_preload" value="5" placeholder="Preload">
                </div>
            </div>

            <div id="fr_inputs_dist" style="display:none;">
                <div class="st-row"><label>Brazos Rck (Push/Damp):</label>
                    <div class="coord-inputs"><input type="number" id="fr_b_push" value="0.10"><input type="number" id="fr_b_damp" value="0.10"></div>
                </div>
                <div class="st-row"><label>Ángulo Pushrod (°):</label><input type="number" id="fr_angle" value="60" placeholder="Respecto al suelo"></div>
                <div class="st-row"><label>Eficiencia Geom (%):</label><input type="number" id="fr_eff_geom" value="95" step="1"></div>
                <div class="st-row"><label>ARB Brazo (m):</label><input type="number" id="fr_arb_brazo" value="0.10"></div>
            </div>

            <div id="fr_inputs_coord" style="display:block; background:#eaf2f8; padding:8px; border-radius:4px; margin-bottom:10px; border:1px solid #d6eaf8;">
                <div style="font-size:0.75rem; color:#2980b9; text-align:center; margin-bottom:5px; font-weight:bold;">COORDENADAS [X, Y, Z] (metros)</div>
                <div class="st-row"><label>Punto de Pivote Rocker:</label>       <div class="coord-inputs"><input type="number" id="fr_p_roc_piv_x" value="0.150"><input type="number" id="fr_p_roc_piv_y" value="0.170"><input type="number" id="fr_p_roc_piv_z" value="0.4"></div></div>
                <div class="st-row"><label>Pushrod @ Rocker:</label>  <div class="coord-inputs"><input type="number" id="fr_p_pr_roc_x" value="0.130"><input type="number" id="fr_p_pr_roc_y" value="0.200"><input type="number" id="fr_p_pr_roc_z" value="0.390"></div></div>
                <div class="st-row"><label>Damper @ Rocker:</label>   <div class="coord-inputs"><input type="number" id="fr_p_dmp_roc_x" value="0.180"><input type="number" id="fr_p_dmp_roc_y" value="0.150"><input type="number" id="fr_p_dmp_roc_z" value="0.400"></div></div>
                <div class="st-row"><label>ARB @ Rocker:</label>       <div class="coord-inputs"><input type="number" id="fr_p_arb_roc_x" value="0.150"><input type="number" id="fr_p_arb_roc_y" value="0.150"><input type="number" id="fr_p_arb_roc_z" value="0.420"></div></div>
                
                <div style="margin:5px 0; border-top:1px dashed #ccc;"></div>
                <div class="st-row"><label>Pushrod @ Upright:</label> <div class="coord-inputs"><input type="number" id="fr_p_pr_upr_x" value="0.130"><input type="number" id="fr_p_pr_upr_y" value="0.500"><input type="number" id="fr_p_pr_upr_z" value="0.175"></div></div>
                <div class="st-row"><label>Damper @ Chassis:</label>  <div class="coord-inputs"><input type="number" id="fr_p_dmp_cha_x" value="0.250"><input type="number" id="fr_p_dmp_cha_y" value="0.20"><input type="number" id="fr_p_dmp_cha_z" value="0.350"></div></div>
                <div class="st-row"><label>ARB Esquina Torsion:</label>       <div class="coord-inputs"><input type="number" id="fr_p_arb_lnk_x" value="0.150"><input type="number" id="fr_p_arb_lnk_y" value="0.150"><input type="number" id="fr_p_arb_lnk_z" value="0.100"></div></div>
                <div class="st-row"><label>ARB Chasis Casing:</label>   <div class="coord-inputs"><input type="number" id="fr_p_arb_piv_x" value="0.150"><input type="number" id="fr_p_arb_piv_y" value="0.150"><input type="number" id="fr_p_arb_piv_z" value="0.100"></div></div>
            </div>

            <div style="border-left: 2px solid #2980b9; padding-left:5px; margin: 5px 0;">
                <div class="st-row"><label>Mod. Rigidez ARB - G(Pa):</label><input type="number" id="fr_arb_g" value="80e9" style="font-size:0.8rem;"></div>
                <div class="st-row"><label>ARB Outer D/Inner D (mm):</label>
                    <div class="coord-inputs"><input type="number" id="fr_arb_od" value="12"><input type="number" id="fr_arb_id" value="0"></div>
                </div>
                <div class="st-row"><label style="color:#d35400;">L. Activa ARB (m):</label><input type="number" id="fr_arb_l_activa" value="0.300"></div>
                <div class="note" id="fr_arb_note_dist">Nota: En modo 'Distancias', se usa el Ancho como L Activa.</div>
                <div class="st-row" id="fr_arb_width_row"><label>ARB Ancho (m):</label><input type="number" id="fr_arb_width" value="0.300"></div>
            </div>

            <div class="st-row"><label>Zeta (Reb/Comp):</label>
                <div class="coord-inputs"><input type="number" id="fr_zeta_reb" value="0.75" step="0.05"><input type="number" id="fr_zeta_comp" value="0.35" step="0.05"></div>
            </div>
            <div class="st-row"><label>Vel. Rodilla (m/s):</label><input type="number" id="fr_v_knee" value="0.05" step="0.01"></div>
            <div class="st-row"><label>V Ref Dyno (Lo/Hi):</label>
                <div class="coord-inputs"><input type="number" id="fr_v_low" value="0.051"><input type="number" id="fr_v_high" value="0.254"></div>
            </div>


            <div class="st-sub-header" style="color:#c0392b; border-top: 2px solid #eee; padding-top:10px;">3. EJE TRASERO</div>

            <div class="st-row"><label>Masa No Susp (Esq):</label><input type="number" id="rr_mu" value="16.0"></div>
            <div class="st-row"><label>K Tire (N/mm):</label><input type="number" id="rr_ktire" value="100.0"></div>
            <div class="st-row"><label>K Resorte (lbs/in):</label><input type="number" id="rr_kspring" value="500"></div>
            <div class="st-row"><label>L. Libre / Solido:</label>
                <div class="coord-inputs"><input type="number" id="rr_lfree" value="115"><input type="number" id="rr_lsolid" value="57"></div>
            </div>
            <div class="st-row"><label>Stroke / Preload:</label>
                <div class="coord-inputs">
                    <input type="number" id="rr_stroke" value="57" placeholder="Stroke">
                    <input type="number" id="rr_preload" value="5" placeholder="Preload">
                </div>
            </div>

            <div id="rr_inputs_dist" style="display:none;">
                <div class="st-row"><label>Brazos Rck (Push/Damp):</label>
                    <div class="coord-inputs"><input type="number" id="rr_b_push" value="0.10"><input type="number" id="rr_b_damp" value="0.10"></div>
                </div>
                <div class="st-row"><label>Ángulo Pushrod (°):</label><input type="number" id="rr_angle" value="60" placeholder="Respecto al suelo"></div>
                <div class="st-row"><label>Eficiencia Geom (%):</label><input type="number" id="rr_eff_geom" value="95" step="1"></div>
                <div class="st-row"><label>ARB Brazo (m):</label><input type="number" id="rr_arb_brazo" value="0.12"></div>
            </div>

            <div id="rr_inputs_coord" style="display:block; background:#fdedec; padding:8px; border-radius:4px; margin-bottom:10px; border:1px solid #fadbd8;">
                <div style="font-size:0.75rem; color:#c0392b; text-align:center; margin-bottom:5px; font-weight:bold;">COORDENADAS [X, Y, Z] (metros)</div>
                <div class="st-row"><label>Punto de Pivote Rocker:</label>       <div class="coord-inputs"><input type="number" id="rr_p_roc_piv_x" value="0.150"><input type="number" id="rr_p_roc_piv_y" value="0.170"><input type="number" id="rr_p_roc_piv_z" value="0.4"></div></div>
                <div class="st-row"><label>Pushrod @ Rocker:</label>  <div class="coord-inputs"><input type="number" id="rr_p_pr_roc_x" value="0.130"><input type="number" id="rr_p_pr_roc_y" value="0.200"><input type="number" id="rr_p_pr_roc_z" value="0.390"></div></div>
                <div class="st-row"><label>Damper @ Rocker:</label>   <div class="coord-inputs"><input type="number" id="rr_p_dmp_roc_x" value="0.180"><input type="number" id="rr_p_dmp_roc_y" value="0.150"><input type="number" id="rr_p_dmp_roc_z" value="0.400"></div></div>
                <div class="st-row"><label>ARB @ Rocker:</label>       <div class="coord-inputs"><input type="number" id="rr_p_arb_roc_x" value="0.150"><input type="number" id="rr_p_arb_roc_y" value="0.150"><input type="number" id="rr_p_arb_roc_z" value="0.420"></div></div>
                
                <div style="margin:5px 0; border-top:1px dashed #ccc;"></div>
                <div class="st-row"><label>Pushrod @ Upright:</label> <div class="coord-inputs"><input type="number" id="rr_p_pr_upr_x" value="0.130"><input type="number" id="rr_p_pr_upr_y" value="0.500"><input type="number" id="rr_p_pr_upr_z" value="0.175"></div></div>
                <div class="st-row"><label>Damper @ Chassis:</label>  <div class="coord-inputs"><input type="number" id="rr_p_dmp_cha_x" value="0.250"><input type="number" id="rr_p_dmp_cha_y" value="0.20"><input type="number" id="rr_p_dmp_cha_z" value="0.350"></div></div>
                <div class="st-row"><label>ARB Esquina Torsion:</label>       <div class="coord-inputs"><input type="number" id="rr_p_arb_lnk_x" value="0.150"><input type="number" id="rr_p_arb_lnk_y" value="0.150"><input type="number" id="rr_p_arb_lnk_z" value="0.100"></div></div>
                <div class="st-row"><label>ARB Chasis Casing:</label>   <div class="coord-inputs"><input type="number" id="rr_p_arb_piv_x" value="0.150"><input type="number" id="rr_p_arb_piv_y" value="0.150"><input type="number" id="rr_p_arb_piv_z" value="0.100"></div></div>
            </div>

            <div style="border-left: 2px solid #c0392b; padding-left:5px; margin: 5px 0;">
                <div class="st-row"><label>Mod. Rigidez ARB - G(Pa):</label><input type="number" id="rr_arb_g" value="80e9" style="font-size:0.8rem;"></div>
                <div class="st-row"><label>ARB Outer D/Inner D (mm):</label>
                    <div class="coord-inputs"><input type="number" id="rr_arb_od" value="11"><input type="number" id="rr_arb_id" value="0"></div>
                </div>
                <div class="st-row"><label style="color:#d35400;">L. Activa ARB (m):</label><input type="number" id="rr_arb_l_activa" value="0.300"></div>
                <div class="note" id="rr_arb_note_dist">Nota: En modo 'Distancias', se usa el Ancho como L Activa.</div>
                <div class="st-row" id="rr_arb_width_row"><label>ARB Ancho (m):</label><input type="number" id="rr_arb_width" value="0.300"></div>
            </div>

            <div class="st-row"><label>Zeta (Reb/Comp):</label>
                <div class="coord-inputs"><input type="number" id="rr_zeta_reb" value="0.75" step="0.05"><input type="number" id="rr_zeta_comp" value="0.35" step="0.05"></div>
            </div>
            <div class="st-row"><label>Vel. Rodilla (m/s):</label><input type="number" id="rr_v_knee" value="0.05" step="0.01"></div>
            <div class="st-row"><label>V Ref Dyno (Lo/Hi):</label>
                <div class="coord-inputs"><input type="number" id="rr_v_low" value="0.051"><input type="number" id="rr_v_high" value="0.254"></div>
            </div>

            <div class="st-row" style="margin-top:15px; border-top:1px solid #ddd; padding-top:5px;">
                <label>Max Plot X (m/s):</label><input type="number" id="gl_v_max_plot" value="0.30">
            </div>

            <button class="st-btn damper-btn" onclick="runDamperCalc()">EJECUTAR SIMULACIÓN</button>
        </div>

        <div class="st-output-container" id="damper-output" style="flex: 2; overflow-y: auto; padding-right: 10px;">
            <div class="st-card">
                <h3 style="border-bottom:none; color:#000;">Visualización Geometría 3D</h3>
                <div id="damper-viz-3d" style="width:100%; height:450px;"></div>
                <div style="font-size:0.8rem; color:#666; text-align:center; padding-top:5px;">
                    <span style="color:red">■ Pushrod</span> | 
                    <span style="color:blue">■ Damper</span> | 
                    <span style="color:green">■ ARB</span> | 
                    <span style="color:black">■ Rocker</span>
                </div>
            </div>

            <div id="damper-results-inner">
                <div style="text-align:center; margin-top:20px; color:#999;">
                    <h3>Esperando cálculo...</h3>
                    <p>Presiona "EJECUTAR SIMULACIÓN" para ver los resultados.</p>
                </div>
            </div>
        </div>
    </div>

<script>    

    // ==========================================
    // LOGICA DE PESTAÑAS Y NAVEGACION
    // ==========================================
    function showApp(appName, tabElement) {
        // Ocultar todos los contenedores
        document.getElementById('app-container-v5').style.display = 'none';
        document.getElementById('app-container-steering').style.display = 'none';
        document.getElementById('app-container-fatigue').style.display = 'none';
        document.getElementById('app-container-brakes').style.display = 'none';
        document.getElementById('app-container-damper').style.display = 'none'; // <--- AGREGAR ESTA LÍNEA

        // Quitar clase active de tabs
        document.querySelectorAll('.g-tab').forEach(t => t.classList.remove('active'));

        // Mostrar el seleccionado
        if(appName === 'v5') {
            document.getElementById('app-container-v5').style.display = 'flex';
            window.dispatchEvent(new Event('resize'));
        } else if (appName === 'steering') {
            document.getElementById('app-container-steering').style.display = 'flex';
        } else if (appName === 'fatigue') {
            document.getElementById('app-container-fatigue').style.display = 'flex';
        } else if (appName === 'brakes') {
            document.getElementById('app-container-brakes').style.display = 'flex';
        } else if (appName === 'damper') {                                    // <--- AGREGAR ESTE BLOQUE
            document.getElementById('app-container-damper').style.display = 'flex';
        }

        // Activar tab
        if(tabElement) tabElement.classList.add('active');
    }

    // ==========================================
    // LOGICA DE LA APP DE FRENOS (NUEVO CODIGO PORTADO + VIZ 2D POLIGONAL)
    // ==========================================
    const b_val = (id) => parseFloat(document.getElementById(id).value) || 0;

    function runBrakeCalc() {
        // 1. INPUTS VEHICULO
        const masa_total = b_val('br_masa');
        const distancia_ejes = b_val('br_wb');
        const h_cg = b_val('br_hcg');
        const dist_delantera_pct = b_val('br_dist');
        const desaceleracion_g = b_val('br_decel');
        const mu_neumatico = b_val('br_mu');
        const downforce_N = b_val('br_df');

        // 2. INPUTS NEUMATICO
        const ancho_nominal = b_val('br_tire_w');
        const perfil = b_val('br_tire_p');
        const llanta_in = b_val('br_rim');

        // CALCULO RADIO NEUMATICO
        const h_flanco = ancho_nominal * (perfil / 100.0);
        const d_llanta = llanta_in * 25.4;
        const d_total = d_llanta + (2 * h_flanco);
        const radio_mm = d_total / 2;
        const factor_aplastamiento = 0.97;
        const radio_efectivo_m = (radio_mm * factor_aplastamiento) / 1000.0;

        // 3. CALCULO DINAMICA
        const g = 9.81;
        const peso_total_N = masa_total * g;
        const peso_estatico_del = peso_total_N * dist_delantera_pct;
        const peso_estatico_tras = peso_total_N * (1 - dist_delantera_pct);
        const transferencia_peso_N = (peso_total_N * desaceleracion_g * h_cg) / distancia_ejes;

        let normal_delantera = peso_estatico_del + transferencia_peso_N;
        let normal_trasera = peso_estatico_tras - transferencia_peso_N;

        if (downforce_N > 0) {
            const ratio_delantero_dinamico = normal_delantera / peso_total_N;
            normal_delantera += downforce_N * ratio_delantero_dinamico;
            normal_trasera += downforce_N * (1 - ratio_delantero_dinamico);
        }

        let alerta_stoppie = "";
        if (normal_trasera < 0) {
            alerta_stoppie = `<div style="background:#ffebee; color:#c62828; padding:10px; border-radius:4px; margin-bottom:10px; font-weight:bold;">⚠️ ALERTA CRÍTICA: Las ruedas traseras se levantan (Stoppie).</div>`;
            normal_trasera = 0;
        }

        // 4. FUERZA Y TORQUE
        const fuerza_frenado_del_total = normal_delantera * mu_neumatico;
        const fuerza_frenado_tras_total = normal_trasera * mu_neumatico;

        const torque_eje_delantero = fuerza_frenado_del_total * radio_efectivo_m;
        const torque_eje_trasero = fuerza_frenado_tras_total * radio_efectivo_m;

        const torque_rueda_del = torque_eje_delantero / 2;
        const torque_rueda_tras = torque_eje_trasero / 2;

        const peso_total_dinamico = normal_delantera + normal_trasera;
        const pct_din_del = (normal_delantera / peso_total_dinamico) * 100;
        const pct_din_tras = (normal_trasera / peso_total_dinamico) * 100;

        // 5. CALCULO PRESION (DESGASTE UNIFORME)
        const num_caras = b_val('br_faces');
        const r_interno_mm = b_val('br_ri');
        const r_externo_mm = b_val('br_ro');
        const theta_1_deg = b_val('br_t1');
        const theta_2_deg = b_val('br_t2');
        const f = b_val('br_f');

        const ri = r_interno_mm / 1000.0;
        const ro = r_externo_mm / 1000.0;
        const theta_rad = (theta_2_deg - theta_1_deg) * (Math.PI / 180.0);
        const termino_geometrico = (Math.pow(ro, 2) - Math.pow(ri, 2));

        function calcularPresionDesgasteUniforme(torqueTarget) {
            if (termino_geometrico <= 0) return 0;
            const T_target = torqueTarget / num_caras;
            const pa_pascales = (2 * T_target) / (theta_rad * f * ri * termino_geometrico);
            const pa_bar = (pa_pascales / 1e6) * 10;
            return pa_bar;
        }

        const pres_bar_del = calcularPresionDesgasteUniforme(torque_rueda_del);
        const pres_bar_tras = calcularPresionDesgasteUniforme(torque_rueda_tras);
        
        // Conversion a MPa para mostrar (CORRECCION SOLICITADA)
        const pres_mpa_del = pres_bar_del / 10;
        const pres_mpa_tras = pres_bar_tras / 10;

        // 6. CALCULO BOMBAS (MASTER CYLINDERS)
        const fuerza_piloto_kg = b_val('br_pilot');
        const pedal_ratio = b_val('br_pratio');
        const eficiencia_pedal = b_val('br_peff');
        const bias_fuerza_delantera = b_val('br_bias');

        const presion_req_del_mpa = pres_bar_del * 0.1;
        const presion_req_tras_mpa = pres_bar_tras * 0.1;

        const fuerza_piloto_N = fuerza_piloto_kg * 9.81;
        const fuerza_total_varillas = fuerza_piloto_N * pedal_ratio * eficiencia_pedal;

        const fuerza_en_bomba_del = fuerza_total_varillas * bias_fuerza_delantera;
        const fuerza_en_bomba_tras = fuerza_total_varillas * (1 - bias_fuerza_delantera);

        const area_req_bomba_del = fuerza_en_bomba_del / presion_req_del_mpa; // mm2
        const d_req_bomba_del = 2 * Math.sqrt(area_req_bomba_del / Math.PI);

        const area_req_bomba_tras = fuerza_en_bomba_tras / presion_req_tras_mpa; // mm2
        const d_req_bomba_tras = 2 * Math.sqrt(area_req_bomba_tras / Math.PI);

        // Seleccion Comercial
        const medidas_std = {
            "5/8  (15.88mm)": 15.875,
            "7/10 (17.78mm)": 17.78,
            "3/4  (19.05mm)": 19.05,
            "13/16 (20.64mm)": 20.637,
            "7/8  (22.23mm)": 22.225,
            "15/16 (23.81mm)": 23.812,
            "1.0  (25.40mm)": 25.4
        };

        function buscarMasCercano(val) {
            let mejor = "-";
            let diff = Infinity;
            for (const [k, v] of Object.entries(medidas_std)) {
                let d = Math.abs(v - val);
                if (d < diff) { diff = d; mejor = k; }
            }
            return mejor;
        }

        const sug_del = buscarMasCercano(d_req_bomba_del);
        const sug_tras = buscarMasCercano(d_req_bomba_tras);

        // --- GENERAR HTML OUTPUT ---
        let html = '';
        
        // Tarjeta 1: Dinámica
        html += `<div class="st-card"><h3>1. Dinámica de Frenado (@ ${desaceleracion_g}g)</h3>`;
        html += alerta_stoppie;
        html += `<div class="st-stats-grid">
            <div class="st-stat-box"><span class="st-stat-label">Transferencia Peso</span><span class="st-stat-value">${transferencia_peso_N.toFixed(0)} N</span></div>
            <div class="st-stat-box info"><span class="st-stat-label">Distribución Dinámica</span><span class="st-stat-value">${pct_din_del.toFixed(0)}% / ${pct_din_tras.toFixed(0)}%</span></div>
            <div class="st-stat-box highlight"><span class="st-stat-label">Torque Req. Del (x1)</span><span class="st-stat-value">${torque_rueda_del.toFixed(1)} Nm</span></div>
            <div class="st-stat-box highlight"><span class="st-stat-label">Torque Req. Tras (x1)</span><span class="st-stat-value">${torque_rueda_tras.toFixed(1)} Nm</span></div>
        </div></div>`;

        // Tarjeta 2: Presiones (Desgaste Uniforme) - AGREGADO MPA
        html += `<div class="st-card"><h3>2. Presión Hidráulica Requerida (Caliper)</h3>`;
        html += `<p style="font-size:0.9rem; color:#666;">Basado en modelo de Desgaste Uniforme con la geometría de pastilla ingresada.</p>`;
        html += `<div class="st-stats-grid">
            <div class="st-stat-box success"><span class="st-stat-label">Presión Delantera</span><span class="st-stat-value">${pres_bar_del.toFixed(1)} Bar</span><span class="st-unit">${pres_mpa_del.toFixed(1)} MPa | ${(pres_bar_del*14.5).toFixed(0)} PSI</span></div>
            <div class="st-stat-box success"><span class="st-stat-label">Presión Trasera</span><span class="st-stat-value">${pres_bar_tras.toFixed(1)} Bar</span><span class="st-unit">${pres_mpa_tras.toFixed(1)} MPa | ${(pres_bar_tras*14.5).toFixed(0)} PSI</span></div>
        </div></div>`;

        // Tarjeta 3: Visualizacion Geometria
        html += `<div class="st-card"><h3>Visualización Geometría de Contacto</h3>
            <div id="brake-viz-container" style="height:450px; background:#fff;"></div>
        </div>`;

        // Tarjeta 4: Bombas
        html += `<div class="st-card"><h3>3. Selección de Bombas (Master Cylinders)</h3>`;
        html += `<table class="st-table">
            <thead><tr><th>Parámetro</th><th>Bomba Delantera</th><th>Bomba Trasera</th></tr></thead>
            <tbody>
                <tr><td>Fuerza en Vástago (N)</td><td>${fuerza_en_bomba_del.toFixed(1)}</td><td>${fuerza_en_bomba_tras.toFixed(1)}</td></tr>
                <tr><td>Presión Objetivo (Bar)</td><td>${pres_bar_del.toFixed(1)}</td><td>${pres_bar_tras.toFixed(1)}</td></tr>
                <tr><td><b>Diámetro Calculado</b></td><td style="color:var(--primary); font-weight:bold;">${d_req_bomba_del.toFixed(2)} mm</td><td style="color:var(--primary); font-weight:bold;">${d_req_bomba_tras.toFixed(2)} mm</td></tr>
                <tr><td><b>Sugerencia Comercial</b></td><td><span class="badge badge-safe">${sug_del}</span></td><td><span class="badge badge-safe">${sug_tras}</span></td></tr>
            </tbody>
        </table>
        <div style="margin-top:10px; font-size:0.85rem; color:#555; background:#f9f9f9; padding:8px; border-radius:4px;">
            <b>Nota:</b> Bomba más chica = Más presión (Pedal suave/largo). Bomba más grande = Menos presión (Pedal duro/corto).
        </div>
        </div>`;

        const container = document.getElementById('brake-output');
        container.innerHTML = html;

        // LLAMAR A LA NUEVA FUNCION DE DIBUJADO 2D
        setTimeout(() => {
            drawBrakeGeometry(r_interno_mm, r_externo_mm, theta_1_deg, theta_2_deg, llanta_in, f);
        }, 100);
    }

    function drawBrakeGeometry(ri, ro, t1, t2, rimIn, f) {
        // CORRECCION CRITICA: USO DE PUNTOS EN LUGAR DE PATH SVG PARA GARANTIZAR FORMA
        // Esto crea el "trapecio curvo" (Sector Anular) perfectamente
        
        const rimMm = rimIn * 25.4;
        const rimRad = rimMm / 2;

        const rad1 = t1 * Math.PI / 180;
        const rad2 = t2 * Math.PI / 180;

        // Generar puntos para el arco exterior
        const x_outer = [], y_outer = [];
        const steps = 30;
        for(let i=0; i<=steps; i++) {
            let t = rad1 + (rad2 - rad1) * (i/steps);
            x_outer.push(ro * Math.cos(t));
            y_outer.push(ro * Math.sin(t));
        }

        // Generar puntos para el arco interior (en reversa para cerrar el loop)
        const x_inner = [], y_inner = [];
        for(let i=0; i<=steps; i++) {
            let t = rad2 - (rad2 - rad1) * (i/steps);
            x_inner.push(ri * Math.cos(t));
            y_inner.push(ri * Math.sin(t));
        }

        // Combinar puntos para el poligono cerrado
        const polyX = x_outer.concat(x_inner);
        const polyY = y_outer.concat(y_inner);
        // Cerrar el poligono
        polyX.push(polyX[0]);
        polyY.push(polyY[0]);

        // Calcular puntos medios para etiquetas
        const midAng = (rad1 + rad2) / 2;
        const pRi = {x: ri * Math.cos(midAng), y: ri * Math.sin(midAng)};
        const pRo = {x: ro * Math.cos(midAng), y: ro * Math.sin(midAng)};
        const pMid = {x: (ri+ro)/2 * Math.cos(midAng), y: (ri+ro)/2 * Math.sin(midAng)};

        // Definir traces
        const tracePad = {
            x: polyX, y: polyY,
            fill: 'toself',
            fillcolor: 'rgba(214, 40, 40, 0.3)',
            line: {color: '#d62828', width: 2},
            mode: 'lines',
            type: 'scatter',
            hoverinfo: 'skip'
        };

        // Trace para la llanta (circulo punteado)
        // Generamos puntos de circulo completo
        const rimX = [], rimY = [];
        for(let i=0; i<=60; i++) {
            let t = (i/60) * 2 * Math.PI;
            rimX.push(rimRad * Math.cos(t));
            rimY.push(rimRad * Math.sin(t));
        }
        const traceRim = {
            x: rimX, y: rimY,
            mode: 'lines',
            line: {color: '#7f8c8d', dash: 'dashdot', width: 1},
            type: 'scatter',
            hoverinfo: 'skip'
        };

        // Annotations
        const layoutAnnotations = [
            { x: 0, y: rimRad, text: `Ø Llanta: ${rimMm.toFixed(0)}mm`, showarrow: true, arrowhead: 1, ax: 0, ay: -20, font: {color: '#7f8c8d'} },
            { x: pRi.x, y: pRi.y, text: `Ri=${ri}`, showarrow: true, arrowhead: 1, ax: -20, ay: 20 },
            { x: pRo.x, y: pRo.y, text: `Re=${ro}`, showarrow: true, arrowhead: 1, ax: 20, ay: 20 },
            { x: pMid.x, y: pMid.y, text: `μ=${f}`, showarrow: false, font: {size: 16, color: '#c0392b', weight: 'bold'} },
            { x: 0, y: 0, text: `θ = ${(t2-t1).toFixed(1)}°`, showarrow: false, yshift: -10, font: {size:10, color:'#555'} }
        ];

        // Definir layout cuadrado para que no se deforme
        const limit = rimRad * 1.3;
        const layout = {
            showlegend: false,
            autosize: true,
            margin: {l:20, r:20, b:20, t:20},
            xaxis: { range: [-limit, limit], showgrid: false, zeroline: false, visible: false, scaleanchor: "y", scaleratio: 1 },
            yaxis: { range: [-limit, limit], showgrid: false, zeroline: false, visible: false },
            annotations: layoutAnnotations,
            shapes: [
                // Lineas radiales guía desde el centro (opcional, para ver el angulo)
                {type: 'line', x0:0, y0:0, x1: ro*Math.cos(rad1), y1: ro*Math.sin(rad1), line:{color:'#eee', dash:'dot'}},
                {type: 'line', x0:0, y0:0, x1: ro*Math.cos(rad2), y1: ro*Math.sin(rad2), line:{color:'#eee', dash:'dot'}}
            ]
        };

        Plotly.newPlot('brake-viz-container', [traceRim, tracePad], layout, {displayModeBar: false, staticPlot: true});
    }

    // ==========================================
    // LOGICA DE LA APP DE FATIGA (NUEVO CODIGO PORTADO)
    // ==========================================
    
    // Función de interpolación lineal equivalente a np.interp
    function interp(x, xp, fp) {
        if (x <= xp[0]) return fp[0];
        if (x >= xp[xp.length - 1]) return fp[fp.length - 1];
        
        // Buscar el indice
        let i = 0;
        while (x > xp[i+1]) i++;
        
        // Interpolar
        let t = (x - xp[i]) / (xp[i+1] - xp[i]);
        return fp[i] + t * (fp[i+1] - fp[i]);
    }

    function obtener_factores_q_aluminio(radio_mm) {
        // DATOS FLEXIÓN (q)
        const r_q_data = [0.0, 0.25, 0.50, 0.75, 1.00, 1.50, 2.00, 2.50, 3.00, 3.50, 4.00];
        const q_data   = [0.0, 0.32, 0.42, 0.51, 0.58, 0.67, 0.73, 0.77, 0.80, 0.82, 0.84];

        // DATOS TORSIÓN (qs)
        const r_qs_data = [0.0, 0.25, 0.50, 1.00, 1.50, 2.00, 2.50, 3.00, 3.50, 4.00];
        const qs_data   = [0.0, 0.45, 0.61, 0.76, 0.83, 0.87, 0.89, 0.91, 0.93, 0.94];

        const q_calc = interp(radio_mm, r_q_data, q_data);
        const qs_calc = interp(radio_mm, r_qs_data, qs_data);

        return [q_calc, qs_calc];
    }

    function obtener_factores_K_concentracion(r, d, D) {
        if (d <= 0) return [1.0, 1.0];

        let rd = r / d;
        let Dd = D / d;

        if (rd < 0) rd = 0;

        // FIGURA A-15-9 (FLEXIÓN - Kt)
        const curves_bending = {
            3.00: [[0.001, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30], [10.0, 2.62, 1.95, 1.68, 1.53, 1.43, 1.36]],
            1.50: [[0.001, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30], [8.0, 2.15, 1.76, 1.58, 1.46, 1.38, 1.32]],
            1.10: [[0.001, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30], [6.0, 1.72, 1.51, 1.40, 1.32, 1.27, 1.23]],
            1.02: [[0.001, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30], [5.0, 1.40, 1.28, 1.22, 1.18, 1.15, 1.12]]
        };

        // FIGURA A-15-8 (TORSIÓN - Kts)
        const curves_torsion = {
            2.00: [[0.001, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30], [8.0, 1.76, 1.47, 1.34, 1.26, 1.21, 1.17]],
            1.33: [[0.001, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30], [7.0, 1.58, 1.38, 1.28, 1.21, 1.17, 1.14]],
            1.20: [[0.001, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30], [6.0, 1.48, 1.31, 1.23, 1.18, 1.14, 1.11]],
            1.09: [[0.001, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30], [5.0, 1.32, 1.22, 1.16, 1.12, 1.09, 1.07]]
        };

        function interpolar_chart(data_dict, target_rd, target_Dd) {
            // Ordenar keys
            const known_Dd = Object.keys(data_dict).map(Number).sort((a,b) => a-b);
            let kt_temp_vals = [];
            
            for (let curve_Dd of known_Dd) {
                // Hay que usar toFixed o similar para acceder al objeto si las keys son strings, pero en JS object keys son strings
                // Buscamos la key original que matchee el numero
                let key = Object.keys(data_dict).find(k => Math.abs(parseFloat(k) - curve_Dd) < 0.001);
                let arrays = data_dict[key];
                let val = interp(target_rd, arrays[0], arrays[1]);
                kt_temp_vals.push(val);
            }
            return interp(target_Dd, known_Dd, kt_temp_vals);
        }

        const Kt_res = interpolar_chart(curves_bending, rd, Dd);
        const Kts_res = interpolar_chart(curves_torsion, rd, Dd);

        return [Kt_res, Kts_res];
    }

    function runFatigueCalc() {
        // --- INPUTS ---
        const f_val = (id) => parseFloat(document.getElementById(id).value) || 0;

        const masa_auto = f_val('fat_masa');
        const dist_ejes = f_val('fat_dist_ejes');
        const trocha_del = f_val('fat_trocha');
        const altura_cg = f_val('fat_altura_cg');
        const reparto_adelante = f_val('fat_reparto');

        const g_frenado = f_val('fat_g_frenado');
        const g_curva = f_val('fat_g_curva');

        const radio_llanta = f_val('fat_radio_llanta');
        const offset_masa = f_val('fat_offset');
        const mu_tire_long = f_val('fat_mu_long');
        const mu_tire_lat = f_val('fat_mu_lat');

        const Sy = f_val('fat_sy');
        const Su = f_val('fat_su');
        const E = f_val('fat_e');

        const r = f_val('fat_r');
        const d = f_val('fat_d');
        const D = f_val('fat_D');
        
        const g = 9.81;

        // --- CALCULOS ---
        const peso_total = masa_auto * g;
        const peso_estatico_del = peso_total * reparto_adelante;
        const transferencia_long = (peso_total * g_frenado * altura_cg) / dist_ejes;
        const peso_delantero_dinamico = peso_estatico_del + transferencia_long;
        const transferencia_lat = (peso_delantero_dinamico * g_curva * altura_cg) / trocha_del;
        const Fz_dinamica = (peso_delantero_dinamico / 2) + transferencia_lat;

        const Fx_req = Fz_dinamica * g_frenado;
        const Fy_req = Fz_dinamica * g_curva;

        const Fx_frenado = -Math.min(Fx_req, Fz_dinamica * mu_tire_long);
        const Fy_lateral = Math.min(Fy_req, Fz_dinamica * mu_tire_lat);

        // Factores Concentracion
        const [q, qs] = obtener_factores_q_aluminio(r);
        const [Kt, Kts] = obtener_factores_K_concentracion(r, d, D);

        const Kf = 1 + q * (Kt - 1);
        const Kfs = 1 + qs * (Kts - 1);

        // Momentos
        const Momento_Flector = (Fz_dinamica * offset_masa) + (Fy_lateral * radio_llanta);
        const Torque_Frenado = Math.abs(Fx_frenado * radio_llanta); 

        // Propiedades Sección
        const J = (Math.PI * Math.pow(d, 4)) / 32;
        const I = (Math.PI * Math.pow(d, 4)) / 64;

        // Tensiones Nominales
        const sigma_flex_nom = (Momento_Flector * (d/2)) / I;
        const tau_tor_nom = (Torque_Frenado * (d/2)) / J;

        // Componentes Media y Alternante
        const sigma_m_flex = 0;
        const sigma_a_flex = sigma_flex_nom * Kf;

        const tau_max_real = tau_tor_nom * Kfs;
        const tau_m_tor = tau_max_real / 2;
        const tau_a_tor = tau_max_real / 2;

        // Von Mises
        const sigma_a_eq = Math.sqrt(Math.pow(sigma_a_flex, 2) + 3 * Math.pow(tau_a_tor, 2));
        const sigma_m_eq = Math.sqrt(Math.pow(sigma_m_flex, 2) + 3 * Math.pow(tau_m_tor, 2));

        // Limite Fatiga
        const Se_prime = 0.4 * Su;
        const ka = 0.87;
        const kb = 0.85;
        const kc = 1.0;
        const kd = 1.0;
        const ke = 0.814;
        const Se = Se_prime * ka * kb * kc * kd * ke;

        // Soderberg
        const termino_a = sigma_a_eq / Se;
        const termino_m = sigma_m_eq / Sy;
        const n = 1 / (termino_a + termino_m);

        // Falla Estática
        const sigma_max_total = sigma_m_eq + sigma_a_eq;
        const n_yield = Sy / sigma_max_total;
        
        // Vida Util
        let sigma_rev_eq = 0;
        if (sigma_m_eq >= Sy) {
            sigma_rev_eq = 999999;
        } else {
            sigma_rev_eq = sigma_a_eq / (1 - (sigma_m_eq / Sy));
        }

        const N1 = 1000.0;
        const S1 = 0.9 * Su;
        const N2 = 5e8;
        const S2 = Se;
        const b = Math.log10(S1 / S2) / Math.log10(N1 / N2);
        const a = S1 / Math.pow(N1, b);
        
        let vida_status = "";
        let vida_detalle = "";

        if (sigma_rev_eq <= Se) {
            vida_status = `<span class="badge badge-safe">VIDA INFINITA TEÓRICA</span>`;
            vida_detalle = "La tensión está por debajo del límite de fatiga corregido (> 500M ciclos).";
        } else if (sigma_rev_eq >= S1) {
            vida_status = `<span class="badge badge-danger">VIDA MUY CORTA</span>`;
            vida_detalle = "Zona de fatiga de bajo ciclaje (< 1,000 ciclos). Peligroso.";
        } else {
            const N_vida = Math.pow((sigma_rev_eq / a), (1/b));
            const vueltas_vida = N_vida / 8; 
            vida_status = `<span class="badge badge-warning">VIDA FINITA</span>`;
            vida_detalle = `Ciclos hasta falla: <b>${Math.floor(N_vida).toLocaleString()}</b><br>Vueltas circuito aprox: <b>${Math.floor(vueltas_vida).toLocaleString()}</b>`;
        }

        // --- CONSTRUCCIÓN DEL DASHBOARD HTML ---
        let html = '';

        // Tarjeta 1: Factores de Concentración
        html += '<div class="st-card"><h3>1. Factores de Concentración de Esfuerzos</h3>';
        html += '<table class="st-table"><thead><tr><th>Parámetro</th><th>Flexión</th><th>Torsión</th></tr></thead><tbody>';
        html += `<tr><td>Sensibilidad de Muesca (q)</td><td>${q.toFixed(3)}</td><td>${qs.toFixed(3)}</td></tr>`;
        html += `<tr><td>Factor Geométrico (Kt)</td><td>${Kt.toFixed(2)}</td><td>${Kts.toFixed(2)}</td></tr>`;
        html += `<tr><td><b>Factor Fatiga (Kf)</b></td><td style="color:var(--primary); font-weight:bold;">${Kf.toFixed(2)}</td><td style="color:var(--primary); font-weight:bold;">${Kfs.toFixed(2)}</td></tr>`;
        html += '</tbody></table></div>';

        // Tarjeta 2: Análisis de Esfuerzos y Soderberg
        let nClass = n < 1 ? 'danger' : (n < 1.5 ? 'warning' : 'success');
        
        html += '<div class="st-card"><h3>2. Criterio de Soderberg (Fatiga)</h3>';
        html += '<div class="st-stats-grid">';
        html += `<div class="st-stat-box"><span class="st-stat-label">Sigma Alternante Eq</span><span class="st-stat-value">${sigma_a_eq.toFixed(1)} MPa</span></div>`;
        html += `<div class="st-stat-box"><span class="st-stat-label">Sigma Media Eq</span><span class="st-stat-value">${sigma_m_eq.toFixed(1)} MPa</span></div>`;
        html += `<div class="st-stat-box info"><span class="st-stat-label">Límite Fatiga (Se)</span><span class="st-stat-value">${Se.toFixed(1)} MPa</span></div>`;
        html += `<div class="st-stat-box ${nClass}"><span class="st-stat-label">Factor Seguridad (n)</span><span class="st-stat-value">${n.toFixed(3)}</span></div>`;
        html += '</div></div>';

        // Tarjeta 3: Estática y Vida Útil
        let staticBadge = n_yield < 1.0 ? `<span class="badge badge-danger">FALLA ESTÁTICA</span>` : `<span class="badge badge-safe">RESISTE IMPACTO</span>`;
        
        html += '<div class="st-card"><h3>3. Análisis Estático y Vida Útil</h3>';
        html += '<table class="st-table" style="margin-bottom:15px;">';
        html += `<tr><td>Tensión Máxima Pico</td><td style="text-align:right;">${sigma_max_total.toFixed(1)} MPa</td></tr>`;
        html += `<tr><td>Límite Fluencia (Sy)</td><td style="text-align:right;">${Sy.toFixed(1)} MPa</td></tr>`;
        html += `<tr><td><b>Estado Estático</b></td><td style="text-align:right;">${staticBadge} (n=${n_yield.toFixed(2)})</td></tr>`;
        html += '</table>';
        
        html += `<div style="background:#f9f9f9; padding:15px; border-radius:6px; border-left:4px solid #666;">`;
        html += `<div style="margin-bottom:5px;"><b>Tensión Reversible Eq:</b> ${sigma_rev_eq.toFixed(1)} MPa</div>`;
        html += `<div style="margin-bottom:5px;"><b>Estado Vida:</b> ${vida_status}</div>`;
        html += `<div style="font-size:0.9rem; color:#555;">${vida_detalle}</div>`;
        html += '</div></div>';

        document.getElementById('fatigue-output').innerHTML = html;
    }

    // ==========================================
    // LOGICA DE LA APP DE DIRECCION (CODIGO ORIGINAL V5)
    // ==========================================
    // Helper para obtener valores numéricos de los inputs de dirección
    const s_val = (id) => parseFloat(document.getElementById(id).value) || 0;

    // Función Principal que orquesta el cálculo
    function runSteeringCalc() {
        const container = document.getElementById('steering-output');
        container.innerHTML = ""; 

        // 1. Generar HTML de Geometría y Piñones
        const htmlGeo = calculateSteeringGeometricHTML();

        // 2. Generar HTML de Esfuerzos (Cremallera y Manos)
        const htmlStress = calculateSteeringStressHTML();

        // 3. CALCULAR EL TORQUE PARA EL CARDAN Y PIÑÓN
        // Recalculamos fuerzas básicas necesarias para pasar a las subfunciones
        const paso = s_val('st_e_paso');
        const z = s_val('st_e_z');
        const brazo_direccion = s_val('st_e_brazo');
        const diam_volante = s_val('st_e_diam');
        
        // --- CALCULO FÍSICO RÁPIDO PARA OBTENER FUERZA DE CREMALLERA ---
        const masa = s_val('st_e_masa');
        const h_cg = s_val('st_e_hcg');
        const trocha = s_val('st_e_trocha');
        const peso_front_pct = s_val('st_e_pf');
        const lltd_front_pct = s_val('st_e_lltd');
        const caster_deg = s_val('st_e_caster');
        const kpi_deg = s_val('st_e_kpi');
        const scrub_radius = s_val('st_e_scrub');
        const pneu_trail = s_val('st_e_pneu');
        const mech_trail = s_val('st_e_mech');
        const steer_angle_deg = s_val('st_e_steer');
        const g_lat = s_val('st_e_glat');
        const g = 9.81;

        const peso_front_static = (masa * g) * (peso_front_pct / 100);
        const delta_w_lat_front = (masa * g * g_lat * h_cg / trocha) * (lltd_front_pct / 100);
        const fz_outer = (peso_front_static / 2) + delta_w_lat_front;
        const fy_outer = fz_outer * g_lat;
        const total_trail = mech_trail + pneu_trail;
        const mz_aligning = fy_outer * total_trail; 
        const kpi_rad = kpi_deg * Math.PI / 180;
        const caster_rad = caster_deg * Math.PI / 180;
        const steer_rad = steer_angle_deg * Math.PI / 180;
        const term_kpi = scrub_radius * Math.sin(kpi_rad);
        const term_caster = mech_trail * Math.sin(caster_rad);
        const mz_jacking = fz_outer * (term_kpi + term_caster) * Math.sin(steer_rad);
        const mz_total = mz_aligning + mz_jacking; 

        const fuerza_cremallera = mz_total / brazo_direccion; // NEWTONS
        const modulo = paso / Math.PI;
        const diametro_primitivo = modulo * z;
        const torque_pinion_nmm = fuerza_cremallera * (diametro_primitivo / 2); 
        const torque_pinion_nm = torque_pinion_nmm / 1000.0; 

        // 4. Obtener inputs específicos del Cardan
        const angulo1 = Math.abs(s_val('st_u_angle1'));
        const angulo2 = Math.abs(s_val('st_u_angle2'));
        const angulo_critico = Math.max(angulo1, angulo2); 
        const diam_efectivo = s_val('st_u_eff_diam');
        const diam_pin = s_val('st_u_pin_diam');

        // Magnificación de Torque (Peor caso estático)
        const rad_critico = angulo_critico * Math.PI / 180;
        let torque_pinion_peak = torque_pinion_nm; 
        if (Math.cos(rad_critico) > 0.05) {
            torque_pinion_peak = torque_pinion_nm / Math.cos(rad_critico);
        } else {
            torque_pinion_peak = torque_pinion_nm * 10; 
        }

        // 5. Generar HTML del Cardan
        const htmlCardan = generateCardanStressReport(torque_pinion_peak, torque_pinion_nm, angulo_critico, diam_efectivo, diam_pin);

        // 6. === NUEVO: GENERAR HTML DEL PIÑÓN (AGMA) ===
        // Pasamos la fuerza en cremallera (Wt) y el torque pico
        const htmlPinion = generatePinionCheckHTML(paso, z, fuerza_cremallera);

        // Renderizar todo junto
        container.innerHTML = htmlGeo + htmlStress + htmlCardan + htmlPinion;

        // GRÁFICOS
        setTimeout(() => {
            renderCardanTorquePlot('cardan-torque-plot', torque_pinion_nm, angulo1, angulo2);
            // Dibujar el piñón
            drawPinionGeometry('pinion-viz-container', paso, z);
        }, 100);
    }

    // <--- PEGAR AQUI function updateScFromHb() --->
    function updateScFromHb() {
        const hb = parseFloat(document.getElementById('st_mat_hb').value) || 0;
        if(hb > 0) {
            const sc_calc = (2.22 * hb) + 200; 
            document.getElementById('st_mat_sc').value = sc_calc.toFixed(0);
        }
    }

    // === GENERADOR HTML PIÑÓN (AGMA) ===
    function generatePinionCheckHTML(paso, z, fuerzaCremalleraN) {
        // Inputs
        const F_mm = s_val('st_g_face');
        const Sc_mpa = s_val('st_mat_sc');
        const Sy_mpa = s_val('st_mat_sy_pinion');
        
        const Ko = s_val('st_k_o');
        const Kv = s_val('st_k_v');
        const Km = s_val('st_k_m');
        
        // Geometría
        const modulo = paso / Math.PI;
        const d_mm = modulo * z;
        const r_mm = d_mm / 2;
        const phi_deg = 20; // Asumimos 20 grados estándar
        const phi_rad = phi_deg * Math.PI / 180;
        
        // 1. RELACIÓN DE CONTACTO (Contact Ratio - mc)
        const a_addendum = modulo; // Diente completo
        const pb = Math.PI * modulo * Math.cos(phi_rad);
        
        const term1 = Math.sqrt(Math.pow(r_mm + a_addendum, 2) - Math.pow(r_mm * Math.cos(phi_rad), 2));
        const term2 = r_mm * Math.sin(phi_rad);
        const term3 = a_addendum / Math.sin(phi_rad);
        
        const Lab = (term1 - term2) + term3;
        const mc = Lab / pb;

        let mc_badge = mc >= 1.2 ? 
            `<span class="badge badge-safe">OK (${mc.toFixed(2)})</span>` : 
            `<span class="badge badge-danger">BAJO (${mc.toFixed(2)})</span>`;

        if(mc < 1.0) mc_badge = `<span class="badge badge-danger" style="background:black; color:red">FALLA (${mc.toFixed(2)})</span>`;

        // 2. ESFUERZO DE CONTACTO (AGMA) - Presión Hertziana
        const Cp = 191; 
        const Ks = 1.0;
        const I_factor = Math.sin(2 * phi_rad) / 4; // ~0.163 para 20 deg
        const Wt = fuerzaCremalleraN;

        const numerator = Wt * Ko * Kv * Ks * Km;
        const denominator = d_mm * F_mm * I_factor;
        
        const sigma_c = Cp * Math.sqrt(numerator / denominator);
        
        // Factores de Seguridad
        const n_contact = Sc_mpa / sigma_c;
        const n_yield = Sy_mpa / sigma_c; 

        // Badges FS
        const badge_contact = n_contact >= 1.0 ? 
            (n_contact >= 1.2 ? `<span class="badge badge-safe">${n_contact.toFixed(2)}</span>` : `<span class="badge badge-warning">${n_contact.toFixed(2)}</span>`) :
            `<span class="badge badge-danger">${n_contact.toFixed(2)}</span>`;

        const badge_yield = n_yield >= 1.0 ? 
            `<span class="badge badge-safe">${n_yield.toFixed(2)}</span>` : 
            `<span class="badge badge-danger">${n_yield.toFixed(2)}</span>`;

        return `
        <div class="st-card" style="border-top: 4px solid #8e44ad;">
            <h3 style="color:#8e44ad; border-bottom: 2px solid #8e44ad;">4. Verificación de Piñón (AGMA 2001)</h3>
            
            <div style="display:flex; flex-direction:row; gap:20px;">
                <div style="flex:1;">
                    <h4 style="text-align:center; margin:0 0 10px 0;">Geometría y Cotas</h4>
                    <div id="pinion-viz-container" style="width:100%; height:250px; border:1px solid #eee;"></div>
                </div>

                <div style="flex:1;">
                    <table class="st-table">
                        <tr><td>Módulo:</td><td style="text-align:right;">${modulo.toFixed(3)}</td></tr>
                        <tr><td>Diámetro Primitivo:</td><td style="text-align:right;">${d_mm.toFixed(2)} mm</td></tr>
                        <tr><td><b>Relación Contacto (mc):</b></td><td style="text-align:right;">${mc_badge}</td></tr>
                    </table>

                    <div style="margin-top:10px; font-size:0.8rem; color:#666;">
                        <b>Parámetros de Cálculo:</b><br>
                        Wt = ${Wt.toFixed(0)} N | Ko=${Ko} | Kv=${Kv} | Km=${Km}
                    </div>

                    <div style="background:#f3e5f5; padding:10px; margin-top:10px; border-radius:4px; border:1px solid #e1bee7;">
                        <div style="text-align:center; font-weight:bold; color:#8e44ad; font-size:1.1em;">
                            Presión Hertziana Máxima: ${sigma_c.toFixed(1)} MPa
                        </div>
                    </div>

                    <table class="st-table" style="margin-top:10px;">
                        <tr>
                            <td>FS vs Sc (Pitting):</td>
                            <td style="text-align:right;">${badge_contact}</td>
                        </tr>
                        <tr>
                            <td>FS vs Sy (Fluencia):</td> 
                            <td style="text-align:right;">${badge_yield}</td>
                        </tr>
                    </table>
                </div>
            </div>
             <div class="note" style="margin-top:5px; text-align:center;">
                * Ecuación: σc = Cp * sqrt( (Wt*Ko*Kv*Km) / (d*F*I) )
             </div>
        </div>
        `;
    }

    // === DIBUJADO DEL PIÑÓN CON COTAS ===
    function drawPinionGeometry(divId, paso, z) {
        const modulo = paso / Math.PI;
        const d_pitch = modulo * z;
        const r_pitch = d_pitch / 2;
        const a = modulo; 
        const b = 1.25 * modulo;
        const r_outer = r_pitch + a;
        const r_root = r_pitch - b;

        // Círculos base
        const steps = 100;
        function circle(r) {
            let x=[], y=[];
            for(let i=0; i<=steps; i++){
                let th = (i/steps)*2*Math.PI;
                x.push(r*Math.cos(th));
                y.push(r*Math.sin(th));
            }
            return {x,y};
        }

        const cPitch = circle(r_pitch);
        const cOuter = circle(r_outer);
        const cRoot = circle(r_root);

        // Trazas
        const tracePitch = {
            x: cPitch.x, y: cPitch.y, mode:'lines', 
            line:{color:'#8e44ad', width:1, dash:'dash'}, 
            name:'Primitivo', hoverinfo:'skip'
        };
        const traceOuter = {
            x: cOuter.x, y: cOuter.y, mode:'lines', 
            line:{color:'#333', width:2}, 
            name:'Exterior', hoverinfo:'skip'
        };
        const traceRoot = {
            x: cRoot.x, y: cRoot.y, mode:'lines', 
            line:{color:'#333', width:1}, 
            name:'Raíz', hoverinfo:'skip'
        };

        // Dibujar un "Diente" esquemático arriba para ponerle cotas
        // Un trapecio simple representando el diente en Y positivo
        const toothW = (Math.PI * modulo) / 2; // Ancho en primitivo
        const angPitch = (toothW / r_pitch); // Angulo que ocupa medio diente
        
        // Coordenadas aproximadas diente
        const tX = [ -toothW/2 * 0.6, -toothW/2, toothW/2, toothW/2 * 0.6, -toothW/2 * 0.6 ];
        const tY = [ r_outer, r_root, r_root, r_outer, r_outer ];
        
        const traceTooth = {
            x: tX, y: tY, mode: 'lines', fill:'toself', fillcolor:'rgba(142, 68, 173, 0.2)',
            line: {color: '#8e44ad', width: 2}, name: 'Diente Ref'
        };

        // Anotaciones (Cotas)
        const annotations = [
            {
                x: 0, y: r_pitch, xref: 'x', yref: 'y',
                text: `D.Prim: ${d_pitch.toFixed(1)}`,
                showarrow: true, arrowhead: 2, ax: 40, ay: -20, font:{size:10, color:'#8e44ad'}
            },
            {
                x: 0, y: r_outer, xref: 'x', yref: 'y',
                text: `D.Ext: ${(r_outer*2).toFixed(1)}`,
                showarrow: true, arrowhead: 2, ax: -40, ay: -30, font:{size:10}
            },
            {
                x: 0, y: 0, xref: 'x', yref: 'y',
                text: `Z=${z}`,
                showarrow: false, font:{size:14, weight:'bold', color:'#ccc'}
            }
        ];

        const layout = {
            margin: {l:10, r:10, b:10, t:10},
            showlegend: false,
            xaxis: {scaleanchor: "y", scaleratio: 1, visible:false},
            yaxis: {visible:false},
            annotations: annotations,
            height: 250
        };

        Plotly.newPlot(divId, [traceOuter, tracePitch, traceRoot, traceTooth], layout, {displayModeBar: false});
    }

    // function calculateSteeringGeometricHTML() ...

    // MÓDULO 1: Análisis Geométrico y Tabla de Selección de Piñones (DISEÑO INVERSO)
    // MÓDULO 1: Análisis Geométrico y Tabla de Selección de Piñones (DISEÑO INVERSO)
    function calculateSteeringGeometricHTML() {
        // --- INPUTS ---
        const giro_volante_req = s_val('st_giro_vol');
        const giro_rueda_req = s_val('st_giro_rueda');
        const fuerza_objetivo_kg = s_val('st_obj_kg');
        const masa = s_val('st_g_masa');
        const h_cg = s_val('st_g_hcg');
        const trocha = s_val('st_g_trocha');
        const peso_front_pct = s_val('st_g_pf');
        const lltd_front_pct = s_val('st_g_lltd');
        const caster_deg = s_val('st_g_caster');
        const kpi_deg = s_val('st_g_kpi');
        const scrub_radius = s_val('st_g_scrub');
        const pneu_trail = s_val('st_g_pneu');
        const mech_trail = s_val('st_g_mech');
        const steer_angle_calc = s_val('st_g_steer');
        const g_lat = s_val('st_g_glat');
        const diam_volante = s_val('st_g_diam');
        const g = 9.81;

        // --- CÁLCULOS FÍSICOS ---
        const peso_front_static = (masa * g) * (peso_front_pct / 100);
        const delta_w_lat_front = (masa * g * g_lat * h_cg / trocha) * (lltd_front_pct / 100);
        const fz_outer = (peso_front_static / 2) + delta_w_lat_front;
        const fy_outer = fz_outer * g_lat;
        const total_trail = mech_trail + pneu_trail;
        const mz_aligning = fy_outer * total_trail; 
        const kpi_rad = kpi_deg * Math.PI / 180;
        const caster_rad = caster_deg * Math.PI / 180;
        const steer_rad = steer_angle_calc * Math.PI / 180;
        const term_kpi = scrub_radius * Math.sin(kpi_rad);
        const term_caster = mech_trail * Math.sin(caster_rad);
        const mz_jacking = fz_outer * (term_kpi + term_caster) * Math.sin(steer_rad);
        const mz_total_nm = (mz_aligning + mz_jacking) / 1000.0;

        // --- MODIFICACIÓN: Se añade la columna Módulo en el <thead> ---
        let html = `<div class="st-card">
            <h3>1. Análisis Geometría & Selección Piñón</h3>
            <div class="st-stats-grid">
                <div class="st-stat-box info"><span class="st-stat-label">Torque Alineación</span><span class="st-stat-value">${(mz_aligning/1000).toFixed(2)} <span class="st-unit">Nm</span></span></div>
                <div class="st-stat-box info"><span class="st-stat-label">Torque Jacking</span><span class="st-stat-value">${(mz_jacking/1000).toFixed(2)} <span class="st-unit">Nm</span></span></div>
                <div class="st-stat-box highlight"><span class="st-stat-label">Torque TOTAL Kingpin</span><span class="st-stat-value">${mz_total_nm.toFixed(2)} <span class="st-unit">Nm</span></span><span class="st-unit" style="font-size:0.7rem">@ ${g_lat}G Lateral</span></div>
                <div class="st-stat-box"><span class="st-stat-label">Objetivo Piloto</span><span class="st-stat-value">${fuerza_objetivo_kg.toFixed(1)} <span class="st-unit">kg</span></span></div>
            </div>
            <table class="st-table"><thead><tr><th>Paso</th><th>Z</th><th>Módulo</th><th>Travel</th><th>Brazo (mm)</th><th>D.Prim</th><th>F. Manos</th><th>Estado</th></tr></thead><tbody>`;

        const pasos_a_probar = [5, 6, 8, 10, 12, 12.5, 15];
        const dientes_a_probar = [10, 11, 12, 13, 14, 15];
        // const seno_rueda_tabla = Math.sin(giro_rueda_req * Math.PI / 180); // YA NO SE USA PARA CALCULAR BRAZO
        const fraccion_vuelta = giro_volante_req / 360.0;

        pasos_a_probar.forEach(paso => {
            dientes_a_probar.forEach(z => {
                const perimetro_pinion = paso * z;
                // Calculamos Travel solo como referencia visual de cuánto se mueve la cremallera con ese volante
                const travel = perimetro_pinion * fraccion_vuelta; 
                
                const modulo = paso / Math.PI;
                const d_primitivo = modulo * z;

                // --- MODIFICACIÓN CLAVE AQUÍ ---
                // En lugar de calcular brazo por ángulos, despejamos el brazo necesario para la fuerza objetivo.
                // Fórmula: Mz = F_manos * (D_Volante / D_Pinion) * Brazo
                // Brazo = (Mz * D_Pinion) / (F_Manos * D_Volante)
                
                let brazo = 0;
                let f_manos_kg = 0;

                if (fuerza_objetivo_kg > 0) {
                    const f_target_n = fuerza_objetivo_kg * g;
                    // mz_total_nm * 1000 para pasar a Nmm
                    brazo = (mz_total_nm * 1000.0 * d_primitivo) / (f_target_n * diam_volante);
                }

                // Recalculamos F. Manos para confirmar (debería dar igual al objetivo +/- decimales)
                if (brazo > 0) {
                    const f_cremallera = (mz_total_nm * 1000.0) / brazo;
                    const t_pinion = f_cremallera * (d_primitivo / 2.0);
                    const f_manos_n = t_pinion / (diam_volante / 2.0);
                    f_manos_kg = f_manos_n / g;
                }

                if (brazo >= 15 && brazo <= 200) { // Amplié un poco el rango de seguridad de visualización
                    let badges = "";
                    // Ajustamos las badges. Ahora "Confort" siempre será verdadero si el cálculo funcionó, 
                    // así que podemos usarlo para indicar si estamos cerca del objetivo (que siempre lo estaremos por fórmula)
                    if (Math.abs(f_manos_kg - fuerza_objetivo_kg) < 1.0) { badges += `<span class="badge badge-confort">OK</span>`; }
                    
                    // Optimo MM sigue indicando si es un número entero bonito para fabricar
                    if (Math.abs(brazo - Math.round(brazo)) < 0.1) { badges += `<span class="badge badge-optimo">ENTERO</span>`; }
                    
                    // --- MODIFICACIÓN: Se añade la celda con el cálculo del Módulo ---
                    html += `<tr><td>${paso}</td><td><b>${z}</b></td><td>${modulo.toFixed(3)}</td><td>${travel.toFixed(1)}</td><td style="font-weight:bold; color:var(--primary)">${brazo.toFixed(1)}</td><td>${d_primitivo.toFixed(1)}</td><td style="font-weight:bold;">${f_manos_kg.toFixed(1)} kg</td><td>${badges}</td></tr>`;
                }
            });
        });
        html += `</tbody></table></div>`;
        return html;
    }

    // MÓDULO 2: Cálculo de Esfuerzos para un caso específico (Detalle)
    function calculateSteeringStressHTML() {
        // --- INPUTS ESPECÍFICOS ---
        const paso = s_val('st_e_paso');
        const z = s_val('st_e_z');
        const brazo_direccion = s_val('st_e_brazo');
        const diametro_volante = s_val('st_e_diam');
        // Inputs heredados o re-ingresados para el caso de carga
        const masa = s_val('st_e_masa');
        const h_cg = s_val('st_e_hcg');
        const trocha = s_val('st_e_trocha');
        const peso_front_pct = s_val('st_e_pf');
        const lltd_front_pct = s_val('st_e_lltd');
        const caster_deg = s_val('st_e_caster');
        const kpi_deg = s_val('st_e_kpi');
        const scrub_radius = s_val('st_e_scrub');
        const pneu_trail = s_val('st_e_pneu');
        const mech_trail = s_val('st_e_mech');
        const steer_angle_deg = s_val('st_e_steer');
        const g_lat = s_val('st_e_glat');
        const g = 9.81;

        // --- CÁLCULOS MECÁNICOS ---
        const modulo = paso / Math.PI;
        const diametro_primitivo = modulo * z;
        const diametro_exterior = (z + 2) * modulo;
        
        // Recálculo de carga dinámica en rueda exterior
        const peso_front_static = (masa * g) * (peso_front_pct / 100);
        const delta_w_lat_front = (masa * g * g_lat * h_cg / trocha) * (lltd_front_pct / 100);
        const fz_outer = (peso_front_static / 2) + delta_w_lat_front;
        const fy_outer = fz_outer * g_lat;
        
        // Torque total en el eje de dirección (Kingpin Axis)
        const total_trail = mech_trail + pneu_trail;
        const mz_aligning = fy_outer * total_trail; 
        
        const kpi_rad = kpi_deg * Math.PI / 180;
        const caster_rad = caster_deg * Math.PI / 180;
        const steer_rad = steer_angle_deg * Math.PI / 180;
        const term_kpi = scrub_radius * Math.sin(kpi_rad);
        const term_caster = mech_trail * Math.sin(caster_rad);
        const mz_jacking = fz_outer * (term_kpi + term_caster) * Math.sin(steer_rad);
        
        const mz_total = mz_aligning + mz_jacking; // En N.mm
        
        // Fuerza requerida en la cremallera para mantener la dirección
        const fuerza_cremallera = mz_total / brazo_direccion; // N
        
        // Torque transferido al piñón
        const torque_pinion = fuerza_cremallera * (diametro_primitivo / 2); // N.mm
        
        // Fuerza tangencial en el volante (fuerza de manos)
        const fuerza_manos_n = torque_pinion / (diametro_volante / 2);
        const fuerza_manos_kg = fuerza_manos_n / g;

        // HTML Output para la tarjeta de detalle
        return `<div class="st-card">
            <h3>2. Detalle de Esfuerzos (Caso Específico)</h3>
            <div class="st-stats-grid">
                <div class="st-stat-box"><span class="st-stat-label">Diámetro Primitivo</span><span class="st-stat-value">${diametro_primitivo.toFixed(2)} <span class="st-unit">mm</span></span></div>
                <div class="st-stat-box"><span class="st-stat-label">Diámetro Exterior</span><span class="st-stat-value">${diametro_exterior.toFixed(2)} <span class="st-unit">mm</span></span></div>
                 <div class="st-stat-box"><span class="st-stat-label">Módulo</span><span class="st-stat-value">${modulo.toFixed(3)}</span></div>
            </div>
            <div style="background:#fff5f5; border:1px solid #ffcccc; padding:15px; border-radius:6px;">
                <h4 style="margin:0 0 10px 0; color:#c0392b;">Resultados Finales de Carga</h4>
                <table class="st-table" style="background:transparent; margin:0;">
                    <tr><td>Torque Autoalineación:</td><td style="text-align:right"><b>${(mz_aligning/1000).toFixed(2)} Nm</b></td></tr>
                    <tr><td>Torque Weight Jacking:</td><td style="text-align:right"><b>${(mz_jacking/1000).toFixed(2)} Nm</b></td></tr>
                    <tr style="border-top:2px solid #ddd"><td><b>Fuerza en Cremallera:</b></td><td style="text-align:right; color:var(--primary); font-size:1.1em;"><b>${fuerza_cremallera.toFixed(1)} N</b></td></tr>
                    <tr><td><b>FUERZA EN MANOS:</b></td><td style="text-align:right; font-size:1.2em;"><b>${fuerza_manos_kg.toFixed(2)} kg</b> <span style="font-size:0.8em; color:#666">(${fuerza_manos_n.toFixed(1)} N)</span></td></tr>
                </table>
            </div>
        </div>`;
    }
    
    // ======================================================
    // GENERADOR DE REPORTE DE CARDAN (ACTUALIZADO CON MAGNIFICACIÓN)
    // ======================================================
    // ======================================================
    // GENERADOR DE REPORTE DE CARDAN (CON CONTENEDOR GRÁFICO)
    // ======================================================
    function generateCardanStressReport(torquePeak, torqueNominal, angleDeg, effDiamMm, pinDiamMm) {
        if (effDiamMm <= 0 || pinDiamMm <= 0) {
            return `<div class="st-card"><h3 style="color:#d35400">3. Esfuerzos en Cardan</h3><p style="color:#aaa; text-align:center;">Faltan dimensiones.</p></div>`;
        }

        const radiusEff = effDiamMm / 2; 
        const forceShearN = (torquePeak * 1000) / radiusEff;
        const pinRadius = pinDiamMm / 2;
        const areaMm2 = Math.PI * Math.pow(pinRadius, 2);
        const shearStressMPa = forceShearN / areaMm2;
        const vonMisesMPa = Math.sqrt(3) * shearStressMPa;
        const limitSy = 300; 
        const fs = limitSy / vonMisesMPa;

        let badgeClass = "badge-danger";
        let badgeText = "FALLA";
        if (fs >= 2.0) { badgeClass = "badge-safe"; badgeText = "OK (Estático)"; } 
        else if (fs >= 1.1) { badgeClass = "badge-warning"; badgeText = "OK (Límite)"; }

        const deltaNm = torquePeak - torqueNominal;
        const deltaPct = torqueNominal > 0 ? (deltaNm / torqueNominal) * 100 : 0;

        let angleWarning = "";
        if (Math.abs(angleDeg) > 15) {
            angleWarning = `<div style="background:#fdedec; color:#c0392b; padding:8px; margin-bottom:15px; border-radius:4px; font-size:0.85rem; border:1px solid #fadbd8;">⚠️ Ángulo > 15° genera vibración torsional y picos de carga.</div>`;
        }

        return `
        <div class="st-card" style="border-top: 4px solid #e67e22;">
            <h3 style="color:#d35400; border-bottom: 2px solid #e67e22;">3. Esfuerzos en Cardan (Cruceta Crítica)</h3>
            
            ${angleWarning}

            <div class="st-stats-grid">
                <div class="st-stat-box">
                    <span class="st-stat-label">ÁNGULO CRÍTICO</span>
                    <span class="st-stat-value">${angleDeg.toFixed(1)}°</span>
                </div>
                <div class="st-stat-box">
                    <span class="st-stat-label">TORQUE PICO (REAL)</span>
                    <span class="st-stat-value">${torquePeak.toFixed(1)} Nm</span>
                    <span class="st-unit" style="color:${deltaNm > 0.1 ? '#c0392b' : '#999'}">
                        Input: ${torqueNominal.toFixed(1)} (+${deltaPct.toFixed(1)}%)
                    </span>
                </div>
                <div class="st-stat-box" style="border-left-color: #2980b9; background-color: #f4f9fd;">
                    <span class="st-stat-label" style="color:#2980b9;">FUERZA MUÑÓN</span>
                    <span class="st-stat-value" style="color:#2c3e50;">${forceShearN.toFixed(0)} N</span>
                </div>
            </div>

            <table class="st-table" style="margin-top:15px;">
                <tr><td style="color:#555;">Diámetro Muñón:</td><td style="text-align:right; font-weight:bold;">${pinDiamMm} mm</td></tr>
                <tr><td style="color:#555;">Esfuerzo Corte (Tau):</td><td style="text-align:right;">${shearStressMPa.toFixed(1)} MPa</td></tr>
                <tr style="background-color: #fff3e0; border-bottom: 2px solid #ffe0b2;"> 
                    <td style="font-weight:bold; color:#d35400;">Esfuerzo Eq. (Von Mises):</td>
                    <td style="text-align:right; font-weight:900; color:#d35400; font-size:1.1em;">${vonMisesMPa.toFixed(1)} MPa</td>
                </tr>
                <tr style="border-top: 2px solid #eee;">
                    <td style="padding-top:12px;">Estado Estático (Ref Sy ${limitSy}):</td>
                    <td style="text-align:right; padding-top:12px;"><span style="font-size:0.9em; margin-right:5px; color:#666;">FS: ${fs.toFixed(2)}</span><span class="badge ${badgeClass}">${badgeText}</span></td>
                </tr>
            </table>

            <div id="cardan-torque-plot" style="width:100%; height:320px; margin-top:25px; border:1px solid #eee; border-radius:4px;"></div>
            
            <div class="note" style="margin-top:10px; color:#999; font-style:italic;">
                * Nota: El gráfico asume crucetas en fase estándar (alineadas) en el eje intermedio. Si los ángulos son iguales, las fluctuaciones se cancelan.
            </div>
        </div>`;
    }

    // ======================================================
    // NUEVA FUNCION DE GRAFICADO (VARIACIÓN DE TORQUE)
    // ======================================================
    function renderCardanTorquePlot(divId, torqueIn, deg1, deg2) {
        if (!torqueIn) torqueIn = 0;
        
        // Convertir a radianes
        const a1 = deg1 * Math.PI / 180;
        const a2 = deg2 * Math.PI / 180;

        const x_vals = [];
        const y_vals = [];

        // Barrido de -135 a 135 grados
        for (let ang = -135; ang <= 135; ang += 2) {
            const th1 = ang * Math.PI / 180;
            
            // 1. Primer Cardan: T_mid = T_in / Ratio_1
            // Factor de Torque J1 = (1 - sin^2(a1)*sin^2(th1)) / cos(a1)
            // (La fórmula de T_salida es T_entrada * Factor)
            const term1 = 1 - Math.pow(Math.sin(a1), 2) * Math.pow(Math.sin(th1), 2);
            const factor1 = term1 / Math.cos(a1);
            const t_mid = torqueIn * factor1;

            // 2. Ángulo intermedio (Cinemática exacta) para alimentar al segundo cardan
            // Tan(th2) = Tan(th1) * Cos(a1)
            // Usamos la identidad cos^2(th2) para evitar calcular atan y problemas de cuadrante
            // cos^2(th2) = cos^2(th1) / (cos^2(th1) + sin^2(th1)*cos^2(a1))
            const cos2_th1 = Math.pow(Math.cos(th1), 2);
            const sin2_th1 = Math.pow(Math.sin(th1), 2);
            const cos2_a1 = Math.pow(Math.cos(a1), 2);
            const cos2_th2 = cos2_th1 / (cos2_th1 + sin2_th1 * cos2_a1);

            // 3. Segundo Cardan (Asumiendo Faseado Estándar/Correcto: 90 grados de desfase)
            // La cancelación ocurre si el yugo de entrada del J2 está a 90 grados del yugo de salida del J1.
            // Esto implica que usamos cos^2(th2) en lugar de sin^2(th2) en la fórmula del segundo joint.
            const term2 = 1 - Math.pow(Math.sin(a2), 2) * cos2_th2; // Usamos cos^2(th2) por el desfase de 90
            const factor2 = term2 / Math.cos(a2);
            
            const t_out = t_mid * factor2;

            x_vals.push(ang);
            y_vals.push(t_out);
        }

        // Configuración Plotly
        const trace = {
            x: x_vals,
            y: y_vals,
            mode: 'lines',
            line: {color: '#e67e22', width: 3},
            fill: 'tozeroy',
            fillcolor: 'rgba(230, 126, 34, 0.1)',
            name: 'Torque Salida'
        };

        const traceInput = {
            x: [-135, 135],
            y: [torqueIn, torqueIn],
            mode: 'lines',
            line: {color: '#999', width: 2, dash:'dot'},
            name: 'Torque Input'
        };

        const layout = {
            title: {text: 'Fluctuación de Torque (2 Cardanes)', font: {size: 14}},
            margin: {l:40, r:20, b:40, t:40},
            xaxis: {title: 'Giro Volante (°)', gridcolor: '#eee', zerolinecolor: '#ccc'},
            yaxis: {title: 'Torque (Nm)', gridcolor: '#eee'},
            showlegend: true,
            legend: {orientation: 'h', y: 1.1},
            plot_bgcolor: '#fff',
            paper_bgcolor: '#fff'
        };

        Plotly.newPlot(divId, [traceInput, trace], layout, {displayModeBar: false});
    }

    // ==========================================
    // 1. UTILIDADES MATEMÁTICAS BÁSICAS (CODIGO ORIGINAL V5)
    // ==========================================
    function sub(a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; }
    function norm(v) { return Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2); }
    function normalize(v) {
        const n = norm(v);
        if (n === 0) return [0, 0, 0];
        return [v[0]/n, v[1]/n, v[2]/n];
    }
    function cross(a, b) {
        return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]];
    }

    // Solver de sistema lineal (Gaussian Elimination) - Versión completa y segura
    function solveLinearSystem(A, B) {
        let n = B.length;
        let M = A.map(row => [...row]);
        let x = [...B];
        for (let i = 0; i < n; i++) {
            let max = Math.abs(M[i][i]);
            let row = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(M[k][i]) > max) { max = Math.abs(M[k][i]); row = k; }
            }
            for (let k = i; k < n; k++) {
                let t = M[row][k]; M[row][k] = M[i][k]; M[i][k] = t;
            }
            let t = x[row]; x[row] = x[i]; x[i] = t;
            for (let k = i + 1; k < n; k++) {
                let c = -M[k][i] / M[i][i];
                for (let j = i; j < n; j++) { M[k][j] += c * M[i][j]; }
                x[k] += c * x[i];
            }
        }
        let res = new Array(n).fill(0);
        for (let i = n - 1; i > -1; i--) {
            let s = 0;
            for (let j = i + 1; j < n; j++) { s += M[i][j] * res[j]; }
            res[i] = (x[i] - s) / M[i][i];
        }
        return res;
    }

    // ==========================================
    // NUEVO MOTOR CINEMÁTICO (GEOMETRÍA REAL)
    // ==========================================
    class KinematicSuspension {
        constructor(coords) {
            this.piv = coords.pivote;       
            this.pr_r = coords.pr_rocker;   
            this.sh_r = coords.sh_rocker;   
            this.sh_c = coords.sh_chassis;  
            this.upr = coords.pr_upright;   

            this.len_pushrod = this.dist(this.pr_r, this.upr);
            this.len_arm_in  = this.dist(this.pr_r, this.piv);  
            this.len_arm_out = this.dist(this.sh_r, this.piv);  
            
            const angle_in = Math.atan2(this.pr_r[1] - this.piv[1], this.pr_r[0] - this.piv[0]);
            const angle_out = Math.atan2(this.sh_r[1] - this.piv[1], this.sh_r[0] - this.piv[0]);
            this.bellcrank_angle = angle_out - angle_in; 
        }

        dist(p1, p2) {
            return Math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2);
        }

        solve(wheel_travel_mm) {
            const new_upr = [this.upr[0], this.upr[1] + (wheel_travel_mm / 1000)];
            const dist_piv_upr = this.dist(this.piv, new_upr);
            
            if (dist_piv_upr > (this.len_pushrod + this.len_arm_in)) return null; 

            const numerator = this.len_arm_in**2 + dist_piv_upr**2 - this.len_pushrod**2;
            const denominator = 2 * this.len_arm_in * dist_piv_upr;
            
            // Protección contra errores numéricos en acos
            let val = numerator / denominator;
            if (val > 1) val = 1; else if (val < -1) val = -1;
            
            const alpha = Math.acos(val);
            const angle_base = Math.atan2(new_upr[1] - this.piv[1], new_upr[0] - this.piv[0]);
            const theta_in_new = angle_base + alpha; 

            const new_pr_r = [
                this.piv[0] + this.len_arm_in * Math.cos(theta_in_new),
                this.piv[1] + this.len_arm_in * Math.sin(theta_in_new)
            ];

            const theta_out_new = theta_in_new + this.bellcrank_angle;
            const new_sh_r = [
                this.piv[0] + this.len_arm_out * Math.cos(theta_out_new),
                this.piv[1] + this.len_arm_out * Math.sin(theta_out_new)
            ];

            const new_shock_len = this.dist(new_sh_r, this.sh_c);

            return {
                shock_len: new_shock_len,
                rocker_angle_rad: theta_in_new,
                pushrod_rocker_angle: this.calculateIncidenceAngle(new_pr_r, new_upr, this.piv)
            };
        }

        getMotionRatio(travel_mm) {
            const step = 0.1; 
            const s1 = this.solve(travel_mm);
            const s2 = this.solve(travel_mm + step);
            
            if (!s1 || !s2) return 0;

            const d_shock = s1.shock_len - s2.shock_len; 
            const d_wheel = step / 1000; 

            return d_shock / d_wheel;
        }

        calculateIncidenceAngle(p_rocker, p_pushrod, p_pivot) {
            const v_arm = [p_rocker[0]-p_pivot[0], p_rocker[1]-p_pivot[1]];
            const v_push = [p_pushrod[0]-p_rocker[0], p_pushrod[1]-p_rocker[1]];
            
            const dot = v_arm[0]*v_push[0] + v_arm[1]*v_push[1];
            const magA = Math.sqrt(v_arm[0]**2 + v_arm[1]**2);
            const magB = Math.sqrt(v_push[0]**2 + v_push[1]**2);
            
            // Protección contra división por cero
            if (magA * magB === 0) return 0;
            return Math.acos(Math.max(-1, Math.min(1, dot / (magA * magB)))); 
        }
    }

    // ==========================================
    // 2. GESTIÓN DE DATOS E INPUTS (CODIGO ORIGINAL V5)
    // ==========================================
    let editingAxle = 'front';
    const val = (id) => parseFloat(document.getElementById(id).value) || 0;
    const col = (id) => document.getElementById(id).value;

    const vehicleData = {
        front: {
            tire_center: [0.0, 0.58665, 0.25465],
            lwb_f: [0.12517, 0.26785, 0.14113], lwb_r: [-0.12483, 0.26785, 0.14113], lwb_u: [-0.0031, 0.58396, 0.16439],
            uwb_f: [0.10508, 0.24562, 0.29095], uwb_r: [-0.14420, 0.24562, 0.27199], uwb_u: [-0.03018, 0.55345, 0.35703], 
            push_c: [-0.00277, 0.2, 0.4], push_u: [-0.00277, 0.55, 0.175],
            tie_c: [-0.200, 0.26785, 0.167680], tie_u: [-0.075, 0.58032, 0.17032],
            p_trail_mm: 30.0
        },
        rear: {
            tire_center: [0.0, 0.58665, 0.25465],
            lwb_f: [0.125, 0.30917, 0.14776], lwb_r: [-0.125, 0.30917, 0.14776], lwb_u: [0.0, 0.58405, 0.16439], 
            uwb_f: [0.12358, 0.28682, 0.27015], uwb_r: [-0.12358, 0.28682, 0.30771], uwb_u: [0.0, 0.55337, 0.35805], 
            push_c: [0.0, 0.2, 0.4], push_u: [0.0, 0.55, 0.175],
            tie_c: [0.100, 0.270, 0.160], tie_u: [0.100, 0.520, 0.160],
            p_trail_mm: 30.0
        }
    };

    function switchTab(axle) {
        editingAxle = axle; 
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active')); 
        event.target.classList.add('active'); 
        renderInputs();
    }

    function renderInputs() {
        const d = vehicleData[editingAxle];
        const container = document.getElementById('active-inputs-container');
        container.innerHTML = `<h4>Hardpoints ${editingAxle.toUpperCase()} [X, Y, Z]</h4>`;
        
        const points = {
            'tire_center':'Centro Rueda',
            'lwb_f':'LWB Chas F','lwb_r':'LWB Chas R','lwb_u':'LWB Uprt',
            'uwb_f':'UWB Chas F','uwb_r':'UWB Chas R','uwb_u':'UWB Uprt',
            'push_c':'Push Chas','push_u':'Push Uprt',
            'tie_c':editingAxle==='front'?'Tie Chas':'Toe Chas',
            'tie_u':editingAxle==='front'?'Tie Uprt':'Toe Uprt'
        };

        for (const [k, l] of Object.entries(points)) { 
            container.innerHTML += `
            <div class="row"><label>${l}</label>
            <div class="coord-inputs">
                <input type="number" value="${d[k][0]}" step="0.005" onchange="updateData('${k}',0,this.value)">
                <input type="number" value="${d[k][1]}" step="0.005" onchange="updateData('${k}',1,this.value)">
                <input type="number" value="${d[k][2]}" step="0.005" onchange="updateData('${k}',2,this.value)">
            </div></div>`; 
        }
        container.innerHTML += `<div class="row" style="margin-top:5px; border-top:1px solid #eee; padding-top:5px;"><label>Pneu. Trail (mm):</label><input type="number" value="${d.p_trail_mm}" onchange="updateScalar('p_trail_mm',this.value)"></div>`;
    }

    function updateData(k,i,v){ vehicleData[editingAxle][k][i]=parseFloat(v); } 
    function updateScalar(k,v){ vehicleData[editingAxle][k]=parseFloat(v); }
    
    function getTireDims() { 
        const w=val('tire_w_inp');
        const ar=val('tire_ar_inp')/100;
        const rimD=val('rim_d_inp')*25.4;
        const swH=w*ar; 
        return { tire_od: rimD+(2*swH), tire_width: w, rim_od: rimD, sidewall_h: swH }; 
    }

    // ==========================================
    // 3. SOLVER FÍSICO (CODIGO ORIGINAL V5)
    // ==========================================
    function calculateAxle(axleType, data, inputs) {
        const g = 9.81;
        const tc = data.tire_center;
        
        const vl_f = normalize(sub(data.lwb_u, data.lwb_f));
        const vl_r = normalize(sub(data.lwb_u, data.lwb_r));
        const vu_f = normalize(sub(data.uwb_u, data.uwb_f));
        const vu_r = normalize(sub(data.uwb_u, data.uwb_r));
        const vp   = normalize(sub(data.push_u, data.push_c));
        const vt   = normalize(sub(data.tie_u, data.tie_c));

        const total_m = inputs.m_total;
        const unsprung = (2 * inputs.unsprung_f) + (2 * inputs.unsprung_r);
        const suspended = total_m - unsprung; 
        
        let mass_corner = 0;
        let trans_lo = 0;
        let trans_la = 0;

        if(axleType === 'front'){
            const susp_f = suspended * inputs.weight_dist_front;
            const static_f = (susp_f / 2) + inputs.unsprung_f;
            trans_lo = (total_m * inputs.g_braking * inputs.cg_height) / inputs.wheelbase;
            const dyn_f = (static_f * 2) + trans_lo; 
            trans_la = (dyn_f * inputs.g_cornering * inputs.cg_height) / inputs.track_front;
            mass_corner = (dyn_f / 2) + trans_la;
        } else {
            const susp_r = suspended * (1 - inputs.weight_dist_front);
            const static_r = (susp_r / 2) + inputs.unsprung_r;
            trans_lo = (total_m * inputs.g_accel * inputs.cg_height) / inputs.wheelbase;
            const dyn_r = (static_r * 2) + trans_lo;
            trans_la = (dyn_r * inputs.g_cornering * inputs.cg_height) / inputs.track_front;
            mass_corner = (dyn_r / 2) + trans_la;
        }

        const Fz = mass_corner * g * inputs.g_bump;
        let Fx = Math.min(mass_corner * g * (axleType==='front' ? inputs.g_braking : inputs.g_accel), Fz * inputs.mu_long);
        if(axleType === 'front') Fx *= -1; 
        
        const Fy = Math.min(mass_corner * g * inputs.g_cornering, Fz * inputs.mu_lat);
        const F_g = [Fx, Fy, Fz];

        const cp_eff = [tc[0] - (data.p_trail_mm / 1000), tc[1], 0.0];
        const r_ground = sub(cp_eff, tc);
        const M_g = cross(r_ground, F_g);

        let trqRem = 0; 
        if(axleType === 'rear'){ trqRem = M_g[1]; M_g[1] = 0; }

        const rl = sub(data.lwb_u, tc);
        const ru = sub(data.uwb_u, tc);
        const rp = sub(data.push_u, tc);
        const rt = sub(data.tie_u, tc);

        const ml_f = cross(rl, vl_f);
        const ml_r = cross(rl, vl_r);
        const mu_f = cross(ru, vu_f);
        const mu_r = cross(ru, vu_r);
        const mp = cross(rp, vp);
        const mt = cross(rt, vt);

        const A = [
            [vl_f[0], vl_r[0], vu_f[0], vu_r[0], vp[0], vt[0]],
            [vl_f[1], vl_r[1], vu_f[1], vu_r[1], vp[1], vt[1]],
            [vl_f[2], vl_r[2], vu_f[2], vu_r[2], vp[2], vt[2]],
            [ml_f[0], ml_r[0], mu_f[0], mu_r[0], mp[0], mt[0]],
            [ml_f[1], ml_r[1], mu_f[1], mu_r[1], mp[1], mt[1]],
            [ml_f[2], ml_r[2], mu_f[2], mu_r[2], mp[2], mt[2]]
        ];
        const B = [-F_g[0], -F_g[1], -F_g[2], -M_g[0], -M_g[1], -M_g[2]];
        
        let res = [0,0,0,0,0,0]; 
        try { 
            res = solveLinearSystem(A, B); 
        } catch(e) { 
            console.error("Error en solver:", e); 
        }

        return { 
            forces: res.map(f => -f), 
            loads: { Fx, Fy, Fz, Mz: M_g[2] }, 
            geo: data, 
            trqRem 
        };
    }

    // ==========================================
    // 4. GENERACIÓN DE REPORTE FEA (CODIGO ORIGINAL V5)
    // ==========================================
    function generateFEAReport(res, inputVals) {
        const geo = res.geo;
        const loads = res.loads;
        const forces = res.forces; 
        
        const brkTorque = inputVals.fea_brake_torque;
        const radiusM = inputVals.fea_mount_radius / 1000;
        const ears = inputVals.fea_ears;
        
        const fTotal = brkTorque / radiusM;
        const fEar = fTotal / ears;

        const linkDefs = [
            { name: "LWB Front Point", pChas: geo.lwb_f, pUprt: geo.lwb_u, force: forces[0] },
            { name: "LWB Rear Point",  pChas: geo.lwb_r, pUprt: geo.lwb_u, force: forces[1] },
            { name: "UWB Front Point", pChas: geo.uwb_f, pUprt: geo.uwb_u, force: forces[2] },
            { name: "UWB Rear Point",  pChas: geo.uwb_r, pUprt: geo.uwb_u, force: forces[3] },
            { name: "Pushrod Mount",   pChas: geo.push_c, pUprt: geo.push_u, force: forces[4] },
            { name: "Tie Rod Mount",   pChas: geo.tie_c,  pUprt: geo.tie_u,  force: forces[5] }
        ];

        let html = `
        <h3 style="color: var(--fea); border-bottom: 2px solid var(--fea); margin-top: 35px; text-align: center; letter-spacing: 1px;">
            ANALISIS DE ESFUERZOS PARA FEA (PORTAMAZAS)
        </h3>`;

        html += `
        <div class="result-block" style="border-top: 4px solid var(--fea); margin-top: 15px;">
            <h3>1. CARGAS DE FRENADO (Caliper)</h3>
            <table>
                <tr><th>Parámetro</th><th>Valor</th></tr>
                <tr><td>Torque Frenado</td><td>${brkTorque.toFixed(1)} Nm</td></tr>
                <tr><td>Radio Montaje</td><td>${(radiusM * 1000).toFixed(1)} mm</td></tr>
                <tr><td>Fuerza Total (Tangencial)</td><td style="color:#ff9f43; font-weight:bold;">${fTotal.toFixed(1)} N</td></tr>
                <tr><td>Fuerza POR OREJA</td><td style="color:#ff9f43; font-weight:bold;">${fEar.toFixed(1)} N</td></tr>
            </table>
            <div class="note" style="color:#aaa; margin-top:5px;">* Nota: La fuerza es tangente al disco (eje Z si caliper a las 3/9 o'clock).</div>
        </div>`;

        html += `
        <div class="result-block">
            <h3>2. FUERZAS EN HARDPOINTS (Vectores)</h3>
            <table>
                <tr>
                    <th>Punto (Hardpoint)</th>
                    <th>Mag (N)</th>
                    <th>Vector [Fx, Fy, Fz]</th>
                </tr>`;

        linkDefs.forEach(link => {
            const vRaw = sub(link.pChas, link.pUprt);
            const vUnit = normalize(vRaw);
            const fx = vUnit[0] * link.force;
            const fy = vUnit[1] * link.force;
            const fz = vUnit[2] * link.force;
            const color = link.force < 0 ? col('color_comp') : col('color_tens');

            html += `
                <tr>
                    <td>${link.name}</td>
                    <td style="color:${color}; font-weight:bold;">${link.force.toFixed(0)}</td>
                    <td class="vector-cell">[${fx.toFixed(0)}, ${fy.toFixed(0)}, ${fz.toFixed(0)}]</td>
                </tr>`;
        });
        html += `</table></div>`;

        html += `
        <div class="result-block">
            <h3>3. REACCIÓN EN RODAMIENTO (Hub)</h3>
            <table>
                <tr><th>Eje</th><th>Fuerza (N)</th><th>Momento (Nm)</th></tr>
                <tr><td>X (Longitudinal)</td><td>${loads.Fx.toFixed(0)}</td><td>${(loads.Fz * (inputVals.wheel_offset/1000)).toFixed(1)} (Aprox Camber)</td></tr>
                <tr><td>Y (Lateral)</td><td>${loads.Fy.toFixed(0)}</td><td>0.0</td></tr>
                <tr><td>Z (Vertical)</td><td>${loads.Fz.toFixed(0)}</td><td>${loads.Mz.toFixed(1)} (Align Tq)</td></tr>
            </table>
            <div class="note" style="color:#aaa;">* Fuerzas del suelo trasladadas al centro del rodamiento.</div>
        </div>`;

        return html;
    }

    // ==========================================
    // 5. VISUALIZACIÓN 3D (CODIGO ORIGINAL V5)
    // ==========================================
    function createRealisticWheelV5(center, tireDims, offset, upLow, upUpp, opacity) {
        const traces = [];
        const rTire = tireDims.tire_od/2000;
        const rRim = tireDims.rim_od/2000;
        const w = tireDims.tire_width/1000;
        const off = offset/1000;
        
        const kp = sub(upUpp, upLow);
        const camber = -Math.atan2(kp[1], kp[2]);
        const rot = (y, z) => [y * Math.cos(camber) - z * Math.sin(camber), y * Math.sin(camber) + z * Math.cos(camber)];

        const makeSurf = (radFn, widFn, co, met, name, yDom = [0, 1]) => {
            const th = [], y = [], xs = [], ys = [], zs = [], st = 36, wst = 8;
            for (let i = 0; i <= st; i++) th.push((i/st)*2*Math.PI);
            for (let i = 0; i <= wst; i++) y.push(yDom[0] + (i/wst)*(yDom[1] - yDom[0]));
            
            for (let i = 0; i < y.length; i++) {
                let rX=[], rY=[], rZ=[], cY=widFn(y[i]), cR=radFn(y[i]);
                for (let j=0; j<th.length; j++) {
                    const [ry, rz] = rot(cY, cR*Math.sin(th[j]));
                    rX.push(center[0]+cR*Math.cos(th[j])); 
                    rY.push(center[1]+ry); 
                    rZ.push(center[2]+rz);
                }
                xs.push(rX); ys.push(rY); zs.push(rZ);
            }
            return { 
                type: 'surface', x: xs, y: ys, z: zs, 
                colorscale: [[0, co], [1, co]], showscale: false, 
                lighting: {ambient:0.4, diffuse:0.8, specular:met?1.5:0.05, roughness:met?0.3:0.9}, 
                name, hoverinfo: 'skip', opacity 
            };
        };

        const twRatio = 0.85, crownDrop = 0.008;
        const treadR = (t) => rTire - crownDrop * Math.pow(2*(t-0.5), 2);
        const treadY = (t) => w*(t-0.5)*twRatio;
        traces.push(makeSurf(treadR, treadY, '#1a1a1a', false, 'Banda Rodadura'));

        const makeCurvedSW = (side, name) => {
            const swR = (t) => rRim + (rTire - crownDrop - rRim) * Math.sin(t*Math.PI/2);
            const swY = (t) => (side * w / 2) * (1 - twRatio * Math.cos(t*Math.PI/2));
            return makeSurf(swR, swY, '#222222', false, name);
        }
        traces.push(makeCurvedSW(-1, 'Sidewall Out')); 
        traces.push(makeCurvedSW(1, 'Sidewall In'));
        
        const rimR = (t) => rRim, rimY = (t) => w*(t-0.5);
        traces.push(makeSurf(rimR, rimY, '#999999', true, 'Barril Llanta'));
        
        const hubR = 0.04, faceR = (t) => hubR*(1-t) + rRim*t, faceY = (t) => off;
        traces.push(makeSurf(faceR, faceY, '#a0a0a0', true, 'Cara Llanta'));
        
        return traces;
    }

    function mirrorY(p) { return [p[0], -p[1], p[2]]; }

    function generateTraces(res, xOff, td, off, co, lbl, tireOp) {
        const g = res.geo, f = res.forces;
        const pos = (p) => [p[0] + xOff, p[1], p[2]];
        
        const links = [
            { n: "LWB F", f: f[0], p1: g.lwb_f, p2: g.lwb_u },
            { n: "LWB R", f: f[1], p1: g.lwb_r, p2: g.lwb_u },
            { n: "UWB F", f: f[2], p1: g.uwb_f, p2: g.uwb_u },
            { n: "UWB R", f: f[3], p1: g.uwb_r, p2: g.uwb_u },
            { n: "Pushrod", f: f[4], p1: g.push_c, p2: g.push_u },
            { n: (lbl.includes('Front')||lbl.includes('F')) ? "Tie Rod" : "Toe Link", f: f[5], p1: g.tie_c, p2: g.tie_u }
        ];

        const traces = links.map(l => {
            const p1 = pos(l.p1), p2 = pos(l.p2), absF = Math.abs(l.f);
            return {
                type: 'scatter3d', mode: 'lines+markers',
                x: [p1[0], p2[0]], y: [p1[1], p2[1]], z: [p1[2], p2[2]],
                line: { color: l.f < 0 ? co.comp : co.tens, width: Math.max(4, Math.min(14, absF / 1000)) },
                marker: { size: 3, color: '#222' },
                name: `${lbl} ${l.n}`, hoverinfo: 'text', text: `${l.n}: ${l.f.toFixed(0)} N`, opacity: 1.0
            };
        });
        
        traces.push({ 
            type: 'scatter3d', mode: 'markers', 
            x: [pos(g.tire_center)[0]], y: [pos(g.tire_center)[1]], z: [0], 
            marker: { symbol: 'cross', size: 5, color: '#333' }, 
            name: 'Suelo', hoverinfo: 'skip', opacity: 1.0 
        });
        
        const wheel = createRealisticWheelV5(pos(g.tire_center), td, off, pos(g.lwb_u), pos(g.uwb_u), tireOp);
        wheel.forEach(t => t.name = lbl + ' ' + t.name);
        return [...traces, ...wheel];
    }

    function generateMirroredTraces(res, xOff, td, off, co, lbl, op) {
        const gM = {};
        for (const k in res.geo) gM[k] = typeof res.geo[k] === 'object' ? mirrorY(res.geo[k]) : res.geo[k];
        return generateTraces({ geo: gM, forces: res.forces }, xOff, td, -off, co, lbl, op);
    }

    function generateChassis(gf, gr, wb) {
        const line = (p1, p2) => ({ 
            type: 'scatter3d', mode: 'lines', 
            x: [p1[0], p2[0]], y: [p1[1], p2[1]], z: [p1[2], p2[2]], 
            line: { color: '#7f8c8d', width: 3 }, hoverinfo: 'skip' 
        });
        
        const pF = (p) => [p[0] + wb, p[1], p[2]];
        const pR = (p) => [p[0], p[1], p[2]];
        const tr = [];
        
        tr.push(line(pF(gf.lwb_f), pF(gf.lwb_r))); 
        tr.push(line(pR(gr.lwb_f), pR(gr.lwb_r))); 
        tr.push(line(pF(gf.lwb_r), pR(gr.lwb_f))); 
        tr.push(line(mirrorY(pF(gf.lwb_r)), mirrorY(pR(gr.lwb_f)))); 
        tr.push(line(pF(gf.uwb_f), pF(gf.uwb_r))); 
        tr.push(line(pR(gr.uwb_f), pR(gr.uwb_r))); 
        tr.push(line(pF(gf.uwb_r), pR(gr.uwb_f))); 
        tr.push(line(mirrorY(pF(gf.uwb_r)), mirrorY(pR(gr.uwb_f)))); 
        
        return tr;
    }

    // ==========================================
    // 6. MAIN CONTROLLER (CODIGO ORIGINAL V5)
    // ==========================================
    function calculateAndPlot() {
        const inputs = {
            g_braking: val('g_braking'), g_accel: val('g_accel'), g_cornering: val('g_cornering'), g_bump: val('g_bump'),
            mu_long: val('mu_long'), mu_lat: val('mu_lat'),
            wheelbase: val('wheelbase')/1000, track_front: val('track_front')/1000, cg_height: val('cg_height')/1000,
            m_total: val('m_total'), weight_dist_front: val('weight_dist_front'),
            unsprung_f: val('unsprung_f'), unsprung_r: val('unsprung_r'),
            fea_brake_torque: val('fea_brake_torque'), fea_mount_radius: val('fea_mount_radius'), fea_ears: val('fea_ears'),
            wheel_offset: val('wheel_offset')
        };

        const tireDims = getTireDims();
        const offset = val('wheel_offset');
        const colors = { comp: col('color_comp'), tens: col('color_tens') };
        const viewMode = document.getElementById('viewMode').value;
        const tireOpacity = document.getElementById('transparent_tires').checked ? 0.3 : 1.0;

        let plots = [], html = "";
        const resF = calculateAxle('front', vehicleData.front, inputs);
        const resR = calculateAxle('rear', vehicleData.rear, inputs);
        const wb = inputs.wheelbase;

        if (viewMode === 'full') {
            plots = plots.concat(generateChassis(vehicleData.front, vehicleData.rear, wb));
            plots = plots.concat(generateTraces(resF, wb, tireDims, offset, colors, "FL", tireOpacity), generateTraces(resR, 0, tireDims, offset, colors, "RL", tireOpacity));
            plots = plots.concat(generateMirroredTraces(resF, wb, tireDims, offset, colors, "FR", tireOpacity), generateMirroredTraces(resR, 0, tireDims, offset, colors, "RR", tireOpacity));
            html += generateTable("DELANTERA (Por Lado)", resF, 'front') + generateTable("TRASERA (Por Lado)", resR, 'rear');
        } else if (viewMode === 'both') {
            plots = plots.concat(generateTraces(resF, wb, tireDims, offset, colors, "Front", tireOpacity), generateTraces(resR, 0, tireDims, offset, colors, "Rear", tireOpacity));
            html += generateTable("SUSP. DELANTERA", resF, 'front') + generateTable("SUSP. TRASERA", resR, 'rear');
        } else if (viewMode === 'front') {
            plots = plots.concat(generateTraces(resF, 0, tireDims, offset, colors, "Front", tireOpacity));
            html += generateTable("SUSP. DELANTERA", resF, 'front');
        } else if (viewMode === 'rear') {
            plots = plots.concat(generateTraces(resR, 0, tireDims, offset, colors, "Rear", tireOpacity));
            html += generateTable("SUSP. TRASERA", resR, 'rear');
        }

        if (viewMode !== 'front') html += calcPowertrain(resR.loads.Fx, tireDims.tire_od);

        document.getElementById('results-output').innerHTML = html;

        // --- INYECCIÓN DEL REPORTE FEA (FORMATEADO) ---
        const feaDiv = document.getElementById('fea-report-container');
        if(viewMode === 'front') {
            feaDiv.innerHTML = generateFEAReport(resF, inputs);
        } else {
            feaDiv.innerHTML = "";
        }

        const layout = {
            margin: { l: 0, r: 0, b: 0, t: 0 },
            paper_bgcolor: '#dae3e7', plot_bgcolor: '#dae3e7',
            scene: {
                aspectmode: "data",
                xaxis: { title: 'X (Adelante+)', backgroundcolor: '#d0dce0' },
                yaxis: { title: 'Y', backgroundcolor: '#d0dce0' },
                zaxis: { title: 'Z', backgroundcolor: '#e0e8ec' },
                camera: { eye: { x: 2.0, y: -2.0, z: 1.2 }, up: { x: 0, y: 0, z: 1 }, center: { x: 0, y: 0, z: -0.3 } },
                dragmode: 'orbit'
            },
            showlegend: true, legend: { x: 0, y: 1, bgcolor: 'rgba(255,255,255,0.5)' }
        };

        Plotly.react('plot3d', plots, layout, { displayModeBar: true });
    }

    function generateTable(title, res, type) {
        const names = type === 'front' ? ["LWB Front", "LWB Rear", "UWB Front", "UWB Rear", "Pushrod", "Tie Rod"] : ["LWB Front", "LWB Rear", "UWB Front", "UWB Rear", "Pushrod", "Toe Link"];
        const linkKeys = [['lwb_f', 'lwb_u'], ['lwb_r', 'lwb_u'], ['uwb_f', 'uwb_u'], ['uwb_r', 'uwb_u'], ['push_c', 'push_u'], ['tie_c', 'tie_u']];
        const yieldS = val('mat_yield'), E = val('mat_E') * 1e9, od = val('tube_od') / 1000, id = val('tube_id') / 1000, sf = val('sf_target');
        const area = (Math.PI / 4) * (od**2 - id**2);
        const I = (Math.PI / 64) * (od**4 - id**4);

        let html = `<div class="result-block"><h3>${title}</h3><table><tr><th>Barra</th><th>Fuerza (N)</th><th>MPa</th><th>FS FLUENCIA</th><th>FS PANDEO</th></tr>`;

        res.forces.forEach((f, i) => {
            const stress = (Math.abs(f) / area) / 1e6;
            const fsY = yieldS / stress;
            let fsB = "-", bc = "";

            if (f < 0) { 
                const k1 = linkKeys[i][0], k2 = linkKeys[i][1];
                const p1 = res.geo[k1], p2 = res.geo[k2];
                if (p1 && p2) {
                    const L = norm(sub(p1, p2));
                    const Pcr = (Math.PI**2 * E * I) / (L**2);
                    const fb = Pcr / Math.abs(f);
                    fsB = fb.toFixed(1);
                    if (fb < sf) bc = fb < 1 ? "danger" : "warning";
                }
            }
            html += `<tr><td>${names[i]}</td><td style="font-weight:bold; color:${f < 0 ? col('color_comp') : col('color_tens')}">${f.toFixed(0)}</td><td>${stress.toFixed(1)}</td><td class="${fsY < sf ? "warning" : "ok"}">${fsY.toFixed(1)}</td><td class="${bc}">${fsB}</td></tr>`;
        });
        return html + `</table><div class="result-footer">Cargas Parche (Por Rueda): Fx=${res.loads.Fx.toFixed(0)}, Fy=${res.loads.Fy.toFixed(0)}, Fz=${res.loads.Fz.toFixed(0)}</div></div><br>`;
    }

    function calcPowertrain(Fx, tOD) {
        const T_e = val('eng_torque'), gr = val('gear_ratio'), ef = val('drivetrain_eff');
        const pod = val('palier_od') / 1000, pid = val('palier_id') / 1000, rT = tOD / 2000;
        const T_w = T_e * gr * ef;
        const T_g = Fx * rT;
        const T_d = Math.min(T_w, T_g);
        const Sy_tensile = val('palier_sy');
        const Sy_shear = Sy_tensile * 0.577;
        const J = (Math.PI / 32) * (pod**4 - pid**4);
        const tau = (T_d * pod / 2) / J / 1e6;
        const fs = Sy_shear / tau;
        return `<div class="result-block" style="border-top:4px solid #fca311"><h3>TREN DE POTENCIA</h3><table><tr><th>Item</th><th>Valor</th></tr><tr><td>Torque Diseño</td><td>${T_d.toFixed(1)} Nm</td></tr><tr><td>Sy Corte (Est)</td><td>${Sy_shear.toFixed(1)} MPa</td></tr><tr><td>FS Torsión</td><td class="${fs < 3.5 ? "warning" : "ok"}"><strong>${fs.toFixed(2)}</strong></td></tr></table></div>`;
    }

    // ==========================================
    // LOGICA PORTADA DE PYTHON (FSAE FULL CAR DAMPER)
    // ==========================================
    
    // Helper para leer inputs de forma segura
    const d_val = (id) => parseFloat(document.getElementById(id).value) || 0;

    // ==========================================
    // FUNCIÓN PUENTE PARA GEOMETRÍA REAL
    // ==========================================
    function ejecutarCalculoCorrecto() {
        // 1. LEER INPUTS EXISTENTES
        const r_in = parseFloat(document.getElementById('fr_b_push').value); 
        const r_out = parseFloat(document.getElementById('fr_b_damp').value);
        const delta_z = parseFloat(document.getElementById('fr_dz').value);  

        // 2. GENERAR COORDENADAS HARDPOINTS (Geometría Virtual)
        let x_in = Math.sqrt(Math.max(0, r_in**2 - delta_z**2));
        
        const coords = {
            pivote:      [0, 0],
            pr_rocker:   [x_in, delta_z],  
            sh_rocker:   [0, r_out],       
            pr_upright:  [0.450, -0.300],  
            sh_chassis:  [-0.300, 0.100]   
        };

        // 3. INSTANCIAR Y CALCULAR
        const susp = new KinematicSuspension(coords);
        const mr_static = susp.getMotionRatio(0);
        const mr_bump = susp.getMotionRatio(25);

        console.log("=== CÁLCULO CINEMÁTICO REAL ===");
        console.log("MR Estático Real:", mr_static.toFixed(3));
        console.log("MR a 25mm (Progresividad):", mr_bump.toFixed(3));
        
        return { mr_static, mr_bump, susp };
    }

    // ==========================================
    // LOGICA NUEVA DE LA APP DE AMORTIGUACIÓN
    // ==========================================

    // Función para alternar visibilidad de inputs (Distancia vs Coordenada)
    function toggleDamperInputs() {
        const mode = document.getElementById('damper_input_mode').value;
        const isDist = (mode === 'dist');
        
        // Frontal
        document.getElementById('fr_inputs_dist').style.display = isDist ? 'block' : 'none';
        document.getElementById('fr_inputs_coord').style.display = isDist ? 'none' : 'block';
        document.getElementById('fr_arb_width_row').style.display = isDist ? 'flex' : 'none'; // En coord se oculta (se usa L_activa + geometria)

        // Trasero
        document.getElementById('rr_inputs_dist').style.display = isDist ? 'block' : 'none';
        document.getElementById('rr_inputs_coord').style.display = isDist ? 'none' : 'block';
        document.getElementById('rr_arb_width_row').style.display = isDist ? 'flex' : 'none';
    }

    // Helper para leer coordenadas como vector
    const d_vec = (prefix) => [
        d_val(prefix + '_x'),
        d_val(prefix + '_y'),
        d_val(prefix + '_z')
    ];

    // Helper distancia
    const getDist = (p1, p2) => Math.sqrt(Math.pow(p1[0]-p2[0], 2) + Math.pow(p1[1]-p2[1], 2) + Math.pow(p1[2]-p2[2], 2));

    function runDamperCalc() {
        const resultsContainer = document.getElementById('damper-results-inner');
        resultsContainer.innerHTML = '<div style="text-align:center; padding:20px; color:#333;">Calculando simulación transitoria (RK4) con Eficiencia...</div>';

        const mode = document.getElementById('damper_input_mode').value; 
        const view3D = document.getElementById('damper_view_mode').value;

        const vehiculo = {
            peso_total_kg: d_val('gl_peso_total'),
            dist_ejes_m: d_val('gl_wb'),
            dist_cg_del_m: d_val('gl_a'),
            altura_cg_m: d_val('gl_hcg'),
            ancho_via_m: d_val('gl_track'),
            downforce_total_N: d_val('gl_df'),
            aero_bal_front_pct: d_val('gl_aero_bal'),
            g_lat: d_val('gl_g_lat'), g_long: d_val('gl_g_long'), v_max_plot: d_val('gl_v_max_plot')
        };
        const track = { v_car: d_val('tr_v_car'), h_bache: d_val('tr_h_bache'), l_bache: d_val('tr_l_bache'), h_piano: d_val('tr_h_piano'), pitch: d_val('tr_pitch'), l_diente: d_val('tr_l_diente') };

        function buildAxleInputs(prefix) {
            let inp = {
                is_coord_mode: (mode === 'coord'),
                mu_kg: d_val(prefix + '_mu'), k_tire_input: d_val(prefix + '_ktire'), k_resorte_lbs_in: d_val(prefix + '_kspring'),
                resorte_l_libre_mm: d_val(prefix + '_lfree'), resorte_l_solido_mm: d_val(prefix + '_lsolid'),
                damper_stroke_mm: d_val(prefix + '_stroke'),
                damper_preload_mm: d_val(prefix + '_preload'),
                
                arb_g: d_val(prefix + '_arb_g'), arb_od_mm: d_val(prefix + '_arb_od'), arb_id_mm: d_val(prefix + '_arb_id'),
                arb_L_activa_m: d_val(prefix + '_arb_l_activa'),
                zeta_reb: d_val(prefix + '_zeta_reb'), zeta_comp: d_val(prefix + '_zeta_comp'), v_knee: d_val(prefix + '_v_knee'),
                v_low: d_val(prefix + '_v_low'), v_high: d_val(prefix + '_v_high'),
                color: (prefix === 'fr') ? '#2980b9' : '#c0392b'
            };
            
            inp.p_rocker_pivot = d_vec(prefix + '_p_roc_piv');
            inp.p_pushrod_rocker = d_vec(prefix + '_p_pr_roc');
            inp.p_damper_rocker = d_vec(prefix + '_p_dmp_roc');
            inp.p_arb_rocker = d_vec(prefix + '_p_arb_roc');
            inp.p_pushrod_upright = d_vec(prefix + '_p_pr_upr');
            inp.p_damper_chassis = d_vec(prefix + '_p_dmp_cha');
            inp.p_arb_droplink_end = d_vec(prefix + '_p_arb_lnk');
            inp.p_arb_pivot_chassis = d_vec(prefix + '_p_arb_piv');

            if (mode === 'coord') {
                inp.brazo_pushrod_m = getDist(inp.p_pushrod_rocker, inp.p_rocker_pivot);
                inp.brazo_damper_m = getDist(inp.p_damper_rocker, inp.p_rocker_pivot);
                inp.brazo_arb_m = getDist(inp.p_arb_rocker, inp.p_rocker_pivot);
                inp.arb_brazo_m = getDist(inp.p_arb_droplink_end, inp.p_arb_pivot_chassis);
                inp.arb_ancho_m = 2 * Math.abs(inp.p_arb_pivot_chassis[1]);
                const vec_pr = [inp.p_pushrod_upright[0]-inp.p_pushrod_rocker[0], inp.p_pushrod_upright[1]-inp.p_pushrod_rocker[1], inp.p_pushrod_upright[2]-inp.p_pushrod_rocker[2]];
                inp.delta_z_m = Math.abs(vec_pr[2]);
            } else {
                inp.brazo_pushrod_m = d_val(prefix + '_b_push');
                inp.brazo_damper_m = d_val(prefix + '_b_damp');
                inp.arb_brazo_m = d_val(prefix + '_arb_brazo');
                inp.arb_ancho_m = d_val(prefix + '_arb_width');
                inp.brazo_arb_m = inp.brazo_pushrod_m * 0.8; 
                inp.pushrod_angle_deg = d_val(prefix + '_angle');
                inp.efficiency_manual = d_val(prefix + '_eff_geom');
            }
            return inp;
        }

        const front_inputs = buildAxleInputs('fr');
        const rear_inputs = buildAxleInputs('rr');

        function getAxleRollStiffness(inp, track_width) {
             let factor_ang = 1.0;
             if (!inp.is_coord_mode && inp.pushrod_angle_deg) {
                factor_ang = Math.sin(inp.pushrod_angle_deg * Math.PI / 180);
             } else if (inp.delta_z_m) {
                 const l_pr_estimated = Math.sqrt(Math.pow(inp.brazo_pushrod_m, 2) + Math.pow(inp.delta_z_m, 2));
                 factor_ang = (l_pr_estimated > 0) ? (Math.abs(inp.delta_z_m) / l_pr_estimated) : 1;
             }
             const mr_damper = factor_ang * (inp.brazo_damper_m / inp.brazo_pushrod_m);
             const brazo_arb_seguro = inp.arb_brazo_m || 0.1;
             const mr_arb = factor_ang * (brazo_arb_seguro / inp.brazo_pushrod_m);
             const k_spring = inp.k_resorte_lbs_in * 175.127;
             const kw_spring = k_spring * Math.pow(mr_damper, 2);
             const od_m = (inp.arb_od_mm || 15) / 1000;
             const id_m = (inp.arb_id_mm || 0) / 1000;
             const J = (Math.PI * (Math.pow(od_m, 4) - Math.pow(id_m, 4))) / 32;
             let L_active = inp.arb_L_activa_m;
             if (!L_active || isNaN(L_active)) L_active = inp.arb_width || 0.3;
             const G_mod = inp.arb_g || 80e9;
             const k_torsion = (G_mod * J) / L_active;
             const lever_arm = inp.arb_brazo_m || 0.1;
             const k_arb_lin = k_torsion / Math.pow(lever_arm, 2);
             const kw_arb = k_arb_lin * Math.pow(mr_arb, 2);
             const k_roll = 0.5 * (kw_spring + kw_arb) * Math.pow(track_width, 2);
             return { k_roll, kw_spring, kw_arb };
        }

        const stiff_f = getAxleRollStiffness(front_inputs, vehiculo.ancho_via_m);
        const stiff_r = getAxleRollStiffness(rear_inputs, vehiculo.ancho_via_m);
        
        const k_roll_total = stiff_f.k_roll + stiff_r.k_roll;
        const lltd_f = (k_roll_total > 0) ? (stiff_f.k_roll / k_roll_total) : 0.5;
        const lltd_r = 1.0 - lltd_f;

        const total_lat_transfer_N = (vehiculo.peso_total_kg * vehiculo.g_lat * 9.81 * vehiculo.altura_cg_m) / vehiculo.ancho_via_m;
        const f_roll_front_N = total_lat_transfer_N * lltd_f; 
        const f_roll_rear_N  = total_lat_transfer_N * lltd_r;

        setTimeout(() => {
            renderDamperGeometry3D('damper-viz-3d', front_inputs, rear_inputs, vehiculo.dist_ejes_m, view3D);

            const res_f = calcularDinamicaEjeJS(front_inputs, vehiculo, true, f_roll_front_N, lltd_f);
            const res_r = calcularDinamicaEjeJS(rear_inputs, vehiculo, false, f_roll_rear_N, lltd_r);
            
            const balance = { 
                kroll_f: stiff_f.k_roll, kroll_r: stiff_r.k_roll, kroll_tot: k_roll_total,
                dist_f: lltd_f, 
                diag: (lltd_f > 0.55 ? "Tendencia SUBVIRAJE (Front Stiff)" : (lltd_f < 0.45 ? "Tendencia SOBREVIRAJE (Rear Stiff)" : "Balance NEUTRAL")),
                k_spr_f: stiff_f.kw_spring, k_arb_f: stiff_f.kw_arb,
                k_spr_r: stiff_r.kw_spring, k_arb_r: stiff_r.kw_arb
            };

            let html = '<div style="display:flex; flex-wrap:wrap; gap:20px;">';
            html += '<div style="flex:1; min-width:350px;">' + generarReporteTexto(res_f, "EJE DELANTERO", "#2980b9", "viz-damper-lin-f") + '</div>';
            html += '<div style="flex:1; min-width:350px;">' + generarReporteTexto(res_r, "EJE TRASERO", "#c0392b", "viz-damper-lin-r") + '</div>';
            html += '</div>';
            
            html += '<div style="margin-top:20px;">' + generarReporteBalance(balance) + '</div>';
            
            html += `<div class="st-card" style="margin-top:20px; color:#000;">
                <h3 style="border-bottom:none; color:#000;">Análisis Gráfico</h3>
                <div id="chart-fv" style="width:100%; height:400px; margin-bottom:30px;"></div>
                <div style="display:flex; gap:20px; flex-wrap:wrap;">
                    <div style="flex:1; min-width:350px; border-right:1px solid #eee; padding-right:10px;"><h4 style="text-align:center; color:#2980b9;">EJE DELANTERO</h4><div id="chart-trans-f" style="height:300px; margin-bottom:10px;"></div><div id="chart-grip-f" style="height:300px; margin-bottom:10px;"></div><div id="chart-photo-f" style="height:300px;"></div></div>
                    <div style="flex:1; padding-left:10px;"><h4 style="text-align:center; color:#c0392b;">EJE TRASERO</h4><div id="chart-trans-r" style="height:300px; margin-bottom:10px;"></div><div id="chart-grip-r" style="height:300px; margin-bottom:10px;"></div><div id="chart-photo-r" style="height:300px;"></div></div>
                </div></div>`;
            
            resultsContainer.innerHTML = html;

            // LLAMADAS CORREGIDAS (Sin precarga)
            drawDamperLinearViz("viz-damper-lin-f", res_f);
            drawDamperLinearViz("viz-damper-lin-r", res_r);

            plotFvComparativo(res_f, res_r, vehiculo.v_max_plot);
            
            const roadBache = (t) => { const v = track.v_car; const T = track.l_bache / v; return (t >= 0 && t <= T) ? (track.h_bache/2)*(1 - Math.cos(2*Math.PI*t/T)) : 0; };
            const roadPiano = (t) => { const v = track.v_car; let x = v * t; return (x % track.pitch <= track.l_diente) ? (track.h_piano/2)*(1 - Math.cos(2*Math.PI*(x%track.pitch)/track.l_diente)) : 0; };

            const sim_f_bache = runRK4(res_f, roadBache, 1.0);
            const sim_f_piano = runRK4(res_f, roadPiano, 1.0);
            const sim_r_bache = runRK4(res_r, roadBache, 1.0);
            const sim_r_piano = runRK4(res_r, roadPiano, 1.0);

            plotTransitorio(sim_f_bache, sim_f_piano, 'chart-trans-f', 'Transitorio (Damper)', res_f.color);
            plotGrip(sim_f_piano, res_f, 'chart-grip-f', 'Grip Neumático (Piano)');
            plotPhotoStyle(sim_f_bache, res_f, 'chart-photo-f', 'Carga Neumático (Bache)');

            plotTransitorio(sim_r_bache, sim_r_piano, 'chart-trans-r', 'Transitorio (Damper)', res_r.color);
            plotGrip(sim_r_piano, res_r, 'chart-grip-r', 'Grip Neumático (Piano)');
            plotPhotoStyle(sim_r_bache, res_r, 'chart-photo-r', 'Carga Neumático (Bache)');
        }, 50);
    }

    // --- FUNCION VISUALIZADOR 3D (CORREGIDA: ROCKER CON LÍNEAS EXTERNAS) ---
    function renderDamperGeometry3D(divId, fInp, rInp, wheelbase, viewMode) {
        const traces = [];
        const wb = wheelbase || 1.65;
        // Si viewMode no viene definido, mostrar ambos por defecto
        const showF = (viewMode === undefined || viewMode === 'both' || viewMode === 'front');
        const showR = (viewMode === undefined || viewMode === 'both' || viewMode === 'rear');

        const line = (p1, p2, color, name, width=4, offset=[0,0,0]) => ({
            type: 'scatter3d', mode: 'lines+markers',
            x: [p1[0]+offset[0], p2[0]+offset[0]], 
            y: [p1[1]+offset[1], p2[1]+offset[1]], 
            z: [p1[2]+offset[2], p2[2]+offset[2]],
            line: {color: color, width: width},
            marker: {size: 3, color: color},
            name: name, showlegend: true
        });

        const createSpring = (p1, p2, color, name, offset=[0,0,0]) => {
            const coils = 12;
            const radius = 0.0125;
            const points = 150;
            const x=[], y=[], z=[];
            const dx = p2[0]-p1[0], dy = p2[1]-p1[1], dz = p2[2]-p1[2];
            const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
            const u = [dx/len, dy/len, dz/len]; 
            let arb = (Math.abs(u[0]) < 0.9) ? [1,0,0] : [0,1,0];
            const v1 = [u[1]*arb[2] - u[2]*arb[1], u[2]*arb[0] - u[0]*arb[2], u[0]*arb[1] - u[1]*arb[0]];
            const v1len = Math.sqrt(v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2]);
            const v = [v1[0]/v1len, v1[1]/v1len, v1[2]/v1len];
            const w = [u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0]];

            for(let i=0; i<=points; i++) {
                const t = i/points;
                const angle = t * coils * 2 * Math.PI;
                const local_x = radius * Math.cos(angle);
                const local_y = radius * Math.sin(angle);
                const local_z = (t * len * 0.8) + (len * 0.1); 
                const gx = p1[0] + offset[0] + local_z*u[0] + local_x*v[0] + local_y*w[0];
                const gy = p1[1] + offset[1] + local_z*u[1] + local_x*v[1] + local_y*w[1];
                const gz = p1[2] + offset[2] + local_z*u[2] + local_x*v[2] + local_y*w[2];
                x.push(gx); y.push(gy); z.push(gz);
            }
            return {
                type: 'scatter3d', mode: 'lines', x:x, y:y, z:z,
                line: {color: color, width: 2}, name: name, showlegend: false, hoverinfo: 'skip'
            };
        };

        // --- EJE DELANTERO ---
        if (showF) {
            const offF = [wb, 0, 0];
            traces.push(line(fInp.p_pushrod_upright, fInp.p_pushrod_rocker, 'red', 'Front Pushrod', 5, offF));
            traces.push(line(fInp.p_damper_rocker, fInp.p_damper_chassis, 'blue', 'Front Damper', 2, offF));
            traces.push(createSpring(fInp.p_damper_rocker, fInp.p_damper_chassis, '#444', 'F Spring', offF));
            traces.push(line(fInp.p_arb_rocker, fInp.p_arb_droplink_end, 'green', 'Front DropLink', 3, offF));
            traces.push(line(fInp.p_arb_droplink_end, fInp.p_arb_pivot_chassis, 'green', 'Front ARB Lever', 5, offF));
            const f_arb_center = [fInp.p_arb_pivot_chassis[0], 0, fInp.p_arb_pivot_chassis[2]];
            traces.push(line(fInp.p_arb_pivot_chassis, f_arb_center, 'green', 'Front ARB Bar', 8, offF));

            traces.push({
                type: 'mesh3d',
                x: [fInp.p_pushrod_rocker[0]+wb, fInp.p_damper_rocker[0]+wb, fInp.p_arb_rocker[0]+wb],
                y: [fInp.p_pushrod_rocker[1], fInp.p_damper_rocker[1], fInp.p_arb_rocker[1]],
                z: [fInp.p_pushrod_rocker[2], fInp.p_damper_rocker[2], fInp.p_arb_rocker[2]],
                color: 'gray', opacity: 0.8, alphahull: 0, name: 'Front Rocker'
            });

            traces.push({
                type:'scatter3d', mode:'markers', 
                x:[fInp.p_rocker_pivot[0]+wb], y:[fInp.p_rocker_pivot[1]], z:[fInp.p_rocker_pivot[2]], 
                marker:{size:6, color:'black', symbol:'circle'}, name:'Pivote F'
            });
            traces.push(line(fInp.p_rocker_pivot, fInp.p_pushrod_rocker, 'black', '', 2, offF));
            traces.push(line(fInp.p_rocker_pivot, fInp.p_damper_rocker, 'black', '', 2, offF));
            traces.push(line(fInp.p_rocker_pivot, fInp.p_arb_rocker, 'black', '', 2, offF));
            
            traces.push(line(fInp.p_pushrod_rocker, fInp.p_damper_rocker, 'black', '', 2, offF));
            traces.push(line(fInp.p_damper_rocker, fInp.p_arb_rocker, 'black', '', 2, offF));
            traces.push(line(fInp.p_arb_rocker, fInp.p_pushrod_rocker, 'black', '', 2, offF));
        }

        // --- EJE TRASERO ---
        if (showR) {
            const offR = [0, 0, 0];
            traces.push(line(rInp.p_pushrod_upright, rInp.p_pushrod_rocker, '#c0392b', 'Rear Pushrod', 5, offR));
            traces.push(line(rInp.p_damper_rocker, rInp.p_damper_chassis, '#2980b9', 'Rear Damper', 2, offR));
            traces.push(createSpring(rInp.p_damper_rocker, rInp.p_damper_chassis, '#444', 'R Spring', offR));
            traces.push(line(rInp.p_arb_rocker, rInp.p_arb_droplink_end, '#27ae60', 'Rear DropLink', 3, offR));
            traces.push(line(rInp.p_arb_droplink_end, rInp.p_arb_pivot_chassis, '#27ae60', 'Rear ARB Lever', 5, offR));
            const r_arb_center = [rInp.p_arb_pivot_chassis[0], 0, rInp.p_arb_pivot_chassis[2]];
            traces.push(line(rInp.p_arb_pivot_chassis, r_arb_center, '#27ae60', 'Rear ARB Bar', 8, offR));

            traces.push({
                type: 'mesh3d',
                x: [rInp.p_pushrod_rocker[0], rInp.p_damper_rocker[0], rInp.p_arb_rocker[0]],
                y: [rInp.p_pushrod_rocker[1], rInp.p_damper_rocker[1], rInp.p_arb_rocker[1]],
                z: [rInp.p_pushrod_rocker[2], rInp.p_damper_rocker[2], rInp.p_arb_rocker[2]],
                color: 'gray', opacity: 0.8, alphahull: 0, name: 'Rear Rocker'
            });

            traces.push({
                type:'scatter3d', mode:'markers', 
                x:[rInp.p_rocker_pivot[0]], y:[rInp.p_rocker_pivot[1]], z:[rInp.p_rocker_pivot[2]], 
                marker:{size:6, color:'black'}, name:'Pivote R'
            });
            traces.push(line(rInp.p_rocker_pivot, rInp.p_pushrod_rocker, 'black', '', 2, offR));
            traces.push(line(rInp.p_rocker_pivot, rInp.p_damper_rocker, 'black', '', 2, offR));
            traces.push(line(rInp.p_rocker_pivot, rInp.p_arb_rocker, 'black', '', 2, offR));

            traces.push(line(rInp.p_pushrod_rocker, rInp.p_damper_rocker, 'black', '', 2, offR));
            traces.push(line(rInp.p_damper_rocker, rInp.p_arb_rocker, 'black', '', 2, offR));
            traces.push(line(rInp.p_arb_rocker, rInp.p_pushrod_rocker, 'black', '', 2, offR));
        }

        const layout = {
            scene: {
                aspectmode: "data",
                xaxis: {title: 'X (Longitudinal)'},
                yaxis: {title: 'Y (Transversal)'},
                zaxis: {title: 'Z (Vertical)'},
                camera: { eye: {x:1.8, y:-1.8, z:1.5} }
            },
            margin: {l:0, r:0, b:0, t:0},
            showlegend: true
        };

        Plotly.newPlot(divId, traces, layout);
    }

    // --- FUNCIONES MATEMATICAS Y SOLVER (PORTADO DE PYTHON) ---

    // AHORA ACEPTA "roll_force_input" (Fuerza de rolido externa calculada por LLTD)
    // VERSIÓN ROBUSTA: Usa Eficiencia de Ángulo (Seno) ignorando inclinación del plano
    // VERSIÓN CORREGIDA: Separa Eficiencia de Reporte (Planar) de Eficiencia Física (Palanca)
    // VERSIÓN CORREGIDA Y CALIBRADA
    // VERSIÓN DEFINITIVA: Lógica Vectorial Basada en Plano de 3 Puntos (Push/Damp/ARB)
    function calcularDinamicaEjeJS(inp, veh, isFront, roll_force_input, lltd_val) {
        const m_susp_total = veh.peso_total_kg - (2*16.0) - (2*18.0); 
        
        let weight_frac, df_share;
        if(isFront) {
            weight_frac = (veh.dist_ejes_m - veh.dist_cg_del_m) / veh.dist_ejes_m;
            df_share = veh.downforce_total_N * veh.aero_bal_front_pct;
        } else {
            weight_frac = veh.dist_cg_del_m / veh.dist_ejes_m;
            df_share = veh.downforce_total_N * (1 - veh.aero_bal_front_pct);
        }
        
        const ms = (m_susp_total * weight_frac) / 2;
        const df_wheel = df_share / 2;

        // --- MATH HELPERS ---
        const _sub = (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
        const _dot = (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        const _cross = (a, b) => [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
        const _mag = (a) => Math.sqrt(_dot(a,a));
        const _norm = (a) => { const m = _mag(a); return m>0 ? [a[0]/m, a[1]/m, a[2]/m] : [0,0,0]; };

        // --- VARIABLES GEOMÉTRICAS ---
        let eff_pushrod = 1.0; 
        let eff_damper = 1.0;  
        let eff_total = 1.0;   
        
        let lever_push = 0.1; // Brazo de palanca efectivo (Radio)
        let lever_damp = 0.1; // Brazo de palanca efectivo (Radio)
        
        let inst_ratio = 1.0;  
        let factor_ang = 1.0;  // Rocker Ratio (Salida/Entrada)
        let p_hat = [0,0,1]; 
        
        if (inp.is_coord_mode && inp.p_rocker_pivot && _mag(inp.p_rocker_pivot) > 0) {
            
            // 1. DEFINIR VECTORES DE FUERZA (Direcciones)
            // Vector Pushrod (Desde Upright hacia Rocker)
            const u_push = _norm(_sub(inp.p_pushrod_rocker, inp.p_pushrod_upright)); 
            // Vector Damper (Desde Chassis hacia Rocker)
            const u_damp = _norm(_sub(inp.p_damper_chassis, inp.p_damper_rocker));
            p_hat = u_push;

            // 2. DEFINIR EL PLANO DEL ROCKER (Usando los 3 puntos de anclaje)
            // Vector A: Push -> Damp
            const v_pd = _sub(inp.p_damper_rocker, inp.p_pushrod_rocker);
            // Vector B: Push -> ARB
            const v_pa = _sub(inp.p_arb_rocker, inp.p_pushrod_rocker);
            
            // Normal del Plano (Producto Cruz)
            let n_vec = _cross(v_pd, v_pa);
            
            // Si los puntos son colineales (error de diseño), usar fallback con el pivote
            if (_mag(n_vec) < 1e-6) {
                const v_fallback = _sub(inp.p_rocker_pivot, inp.p_pushrod_rocker);
                n_vec = _cross(v_pd, v_fallback);
            }
            
            const n_hat = _norm(n_vec); // Vector Normal Unitario del Rocker

            // 3. CALCULAR EFICIENCIAS (Seno del ángulo con la Normal)
            // Identidad: El seno del ángulo entre un vector y la normal es sqrt(1 - cos^2)
            // Si el vector está en el plano, es perpendicular a la normal => cos(90)=0 => sqrt(1)=1 (100%)
            
            const dot_push = _dot(u_push, n_hat); // Coseno con la normal
            eff_pushrod = Math.sqrt(Math.max(0, 1 - dot_push*dot_push));

            const dot_damp = _dot(u_damp, n_hat); // Coseno con la normal
            eff_damper = Math.sqrt(Math.max(0, 1 - dot_damp*dot_damp));
            
            eff_total = eff_pushrod * eff_damper;

            // 4. CALCULAR BRAZOS DE PALANCA (Distancia Punto a Eje de Rotación)
            // El Eje de Rotación pasa por el Pivote y tiene dirección n_hat.
            // Fórmula distancia Punto P a Línea (A, n): d = |(P-A) x n| / |n|
            
            // Brazo Pushrod
            const r_push_vec = _sub(inp.p_pushrod_rocker, inp.p_rocker_pivot);
            lever_push = _mag(_cross(r_push_vec, n_hat)); // Distancia perpendicular al eje

            // Brazo Damper
            const r_damp_vec = _sub(inp.p_damper_rocker, inp.p_rocker_pivot);
            lever_damp = _mag(_cross(r_damp_vec, n_hat)); // Distancia perpendicular al eje

            // 5. INSTALLATION RATIO (Componente Z del Pushrod)
            inst_ratio = Math.abs(u_push[2]); 

            // 6. ROCKER RATIO (Relación de Palancas Puras)
            if (lever_push > 0.001) {
                factor_ang = lever_damp / lever_push;
            } else {
                factor_ang = 1.0;
            }

        } else {
            // MODO DISTANCIAS (MANUAL)
            const angle = inp.pushrod_angle_deg || 90;
            inst_ratio = Math.sin(angle * (Math.PI / 180));
            factor_ang = 1.0;
            if (inp.brazo_pushrod_m > 0) factor_ang = inp.brazo_damper_m / inp.brazo_pushrod_m;
            
            if(inp.efficiency_manual !== undefined && !isNaN(inp.efficiency_manual)) {
                eff_total = inp.efficiency_manual / 100.0;
                eff_pushrod = eff_total; 
                eff_damper = 1.0;
            }
        }

        // --- CÁLCULO DE MOTION RATIO TOTAL ---
        // MR = (Palanca Salida / Palanca Entrada) * (Relación Instalación Rueda)
        let mr_damper = factor_ang * inst_ratio; 
        
        // Protección
        if(mr_damper < 0.1) mr_damper = 0.1;

        // Wheel Rate
        const k_tire = inp.k_tire_input * 1000; 
        const k_spring = inp.k_resorte_lbs_in * 175.127; 
        const kw_spring = k_spring * Math.pow(mr_damper, 2);

        // --- ARB ---
        const od_m = (inp.arb_od_mm || 15) / 1000;
        const id_m = (inp.arb_id_mm || 0) / 1000;
        const J = (Math.PI * (Math.pow(od_m, 4) - Math.pow(id_m, 4))) / 32;
        let L_active = inp.arb_L_activa_m;
        if (!L_active || isNaN(L_active)) L_active = inp.arb_width || 0.3;
        const G_mod = inp.arb_g || 80e9;
        const k_torsion = (G_mod * J) / L_active; 
        
        // Brazo ARB (Usando la misma lógica geométrica si es posible, sino aprox)
        let lever_arb = inp.brazo_arb_m; // fallback coordinate calculation or input
        if (inp.is_coord_mode && inp.p_rocker_pivot) {
             // Calculamos palanca real ARB también
             const v_pa = _sub(inp.p_arb_rocker, inp.p_pushrod_rocker);
             const v_pd = _sub(inp.p_damper_rocker, inp.p_pushrod_rocker);
             let n_vec_arb = _cross(v_pd, v_pa); 
             if (_mag(n_vec_arb) < 1e-6) n_vec_arb = [0,0,1];
             const n_hat_arb = _norm(n_vec_arb);
             
             const r_arb_vec = _sub(inp.p_arb_rocker, inp.p_rocker_pivot);
             lever_arb = _mag(_cross(r_arb_vec, n_hat_arb));
        }
        
        // MR ARB
        const mr_arb = (lever_push > 0) ? (lever_arb / lever_push) * inst_ratio : inst_ratio;
        
        const lever_arm_arb_link = inp.arb_brazo_m || 0.1; // Brazo de la barra en sí (no del rocker)
        const k_arb_lin = k_torsion / Math.pow(lever_arm_arb_link, 2);
        const kw_arb = k_arb_lin * Math.pow(mr_arb, 2); 

        // Cargas Verticales
        const f_static = (ms * 9.81) + df_wheel;
        const trans_long_tot = (veh.peso_total_kg * veh.g_long * 9.81 * veh.altura_cg_m) / veh.dist_ejes_m;
        const delta_f_long = (trans_long_tot * weight_frac)/2; 
        const delta_f_roll = roll_force_input || 0; 
        const f_total_wheel = f_static + delta_f_long + delta_f_roll; 

        // FUERZAS INTERNAS (Fuerza Axial en Pushrod)
        let f_pushrod_axial = 0;
        if (inst_ratio > 0.05) {
            f_pushrod_axial = f_total_wheel / inst_ratio;
        } else {
            f_pushrod_axial = f_total_wheel * 20; 
        }

        // Fuerza Efectiva (que genera torque útil) vs Desalineación
        const f_effective = f_pushrod_axial * eff_total; 
        const f_misalign = f_pushrod_axial * (1 - eff_total);

        // Recorridos
        const tr_static_wheel_m = f_static / kw_spring;
        const tr_static_damp_mm = (tr_static_wheel_m * mr_damper) * 1000;
        const sag_natural_mm = tr_static_damp_mm - inp.damper_preload_mm;

        const tr_long_wheel_m = delta_f_long / kw_spring;
        const tr_roll_wheel_m = delta_f_roll / (kw_spring + kw_arb);
        const tr_dyn_wheel_m = tr_long_wheel_m + tr_roll_wheel_m;
        const travel_g_damp_mm = (tr_dyn_wheel_m * mr_damper) * 1000;
        const travel_total_damp_mm = sag_natural_mm + travel_g_damp_mm;

        const tr_damp_mm_absolute = tr_static_damp_mm + travel_g_damp_mm; 
        const margen_coil = inp.resorte_l_libre_mm - inp.damper_preload_mm - travel_total_damp_mm - inp.resorte_l_solido_mm;

        // Dynamic Params
        const wn = Math.sqrt(kw_spring / ms);
        const fn = wn / (2 * Math.PI);
        const k_ride = (kw_spring * k_tire) / (kw_spring + k_tire); 
        const f_susp = f_total_wheel * (kw_spring / (kw_spring + k_tire));
        const f_damp = f_susp / mr_damper;
        const c_crit = 2 * Math.sqrt(kw_spring * ms); 
        const c_reb = (inp.zeta_reb * c_crit) / Math.pow(mr_damper, 2);
        const c_comp = (inp.zeta_comp * c_crit) / Math.pow(mr_damper, 2);

        return {
            ms, mu: inp.mu_kg, mr_damper, kw_spring, kw_arb, k_tire, k_ride, fn,
            f_damp, tr_damp_mm: tr_damp_mm_absolute, margen_coil, c_reb, c_comp,
            f_total: f_total_wheel, color: inp.color,
            v_low: inp.v_low, v_high: inp.v_high,
            sag_mm: sag_natural_mm,
            travel_g_mm: travel_g_damp_mm,
            travel_total_mm: travel_total_damp_mm,
            stroke_mm: inp.damper_stroke_mm,
            lltd: lltd_val,
            eff_pushrod, eff_damper, eff_total,
            f_pushrod_axial, f_effective, f_misalign
        };
    }

    function calcularBalanceJS(f, r, veh) {
        const kroll_f = ((f.kw_spring + f.kw_arb) * veh.ancho_via_m**2) / 2;
        const kroll_r = ((r.kw_spring + r.kw_arb) * veh.ancho_via_m**2) / 2;
        const kroll_tot = kroll_f + kroll_r;
        const dist_f = kroll_f / kroll_tot;
        
        let diag = "Balance NEUTRAL";
        if(dist_f > 0.55) diag = "Tendencia SUBVIRAJE (Front Stiff)";
        if(dist_f < 0.45) diag = "Tendencia SOBREVIRAJE (Rear Stiff)";

        return { kroll_f, kroll_r, kroll_tot, dist_f, diag, 
                 k_spr_f: (f.kw_spring*veh.ancho_via_m**2)/2, k_arb_f: (f.kw_arb*veh.ancho_via_m**2)/2, 
                 k_spr_r: (r.kw_spring*veh.ancho_via_m**2)/2, k_arb_r: (r.kw_arb*veh.ancho_via_m**2)/2 };
    }


    // --- FUNCION ACTUALIZADA: GRAFICO CON MARGEN AL COIL BIND ---
    // --- FUNCION ACTUALIZADA: GRAFICO CON COTAS Y ALERTAS DE EXCESO ---
    function drawDamperLinearViz(elementId, res) {
        const sag = res.sag_mm;
        const dyn = res.travel_g_mm;
        const total_used = sag + dyn;
        const stroke = res.stroke_mm;
        
        // Posición absoluta del Coil Bind desde el inicio (0)
        // res.margen_coil es la distancia que falta para bloquear (o negativa si ya bloqueó)
        const coil_bind_pos = total_used + res.margen_coil;

        // Distancia remanente visual (si no hay choque)
        const dist_to_coil_bind = coil_bind_pos - total_used;
        const remaining_stroke = stroke - total_used;
        const visual_remaining = Math.max(0, Math.min(remaining_stroke, dist_to_coil_bind));

        // --- TRAZAS (Barras) ---
        // 1. Barra Sag (Verde)
        const traceSag = {
            x: [sag], y: [''], name: 'Sag', orientation: 'h', type: 'bar',
            marker: {color: '#2ecc71', line: {color: 'black', width: 1}},
            text: `Sag: ${sag.toFixed(1)}`, textposition: 'auto', hoverinfo: 'text+name'
        };

        // 2. Barra Compresión G (Naranja)
        const traceDyn = {
            x: [dyn], y: [''], name: 'Compresión G', orientation: 'h', type: 'bar',
            marker: {color: '#f39c12', line: {color: 'black', width: 1}},
            text: `G: ${dyn.toFixed(1)}`, textposition: 'auto', hoverinfo: 'text+name'
        };

        // 3. Barra Margen Coil (Rojo tenue, solo si hay margen positivo)
        const traceCoilMargin = {
            x: [Math.max(0, dist_to_coil_bind)], 
            y: [''], base: [total_used], name: 'Margen al Coil Bind', orientation: 'h', type: 'bar',
            marker: { color: 'rgba(231, 76, 60, 0.4)', line: {color: '#c0392b', width: 1, dash: 'dot'} },
            text: dist_to_coil_bind > 0 ? `Margen: ${dist_to_coil_bind.toFixed(1)}` : '',
            textposition: 'auto', textfont: {color: '#c0392b', weight: 'bold'}, hoverinfo: 'text+name'
        };

        // 4. Barra Stroke Libre (Gris, solo si el stroke es el limitante posterior)
        const traceRem = {
            x: [Math.max(0, remaining_stroke - dist_to_coil_bind)],
            y: [''], base: [coil_bind_pos], name: 'Stroke Libre', orientation: 'h', type: 'bar',
            marker: {color: '#ecf0f1', line: {color: '#bdc3c7', width: 1}},
            hoverinfo: 'name'
        };

        const data = [traceSag, traceDyn, traceCoilMargin, traceRem];

        // --- CALCULOS DE SOBREPASO (EXCESOS) ---
        const annotations = [];
        const shapes = [];

        // A. Etiquetas Estándar (Max Stroke y Coil Bind)
        annotations.push(
            { x: stroke, y: 1, xref: 'x', yref: 'paper', text: 'Max Stroke', showarrow: false, font: {size: 9, color: '#555'}, yshift: 5 },
            { x: coil_bind_pos, y: 0, xref: 'x', yref: 'paper', text: 'Coil Bind', showarrow: true, arrowhead: 2, ax: 0, ay: -25, font: {size: 9, color: '#c0392b', weight:'bold'} }
        );

        // B. CÁLCULO DE DIFERENCIA ENTRE COIL BIND Y STROKE (Tu primer pedido)
        // Dibujamos una cota entre la línea de Coil Bind y la de Max Stroke
        const min_limit = Math.min(stroke, coil_bind_pos);
        const max_limit = Math.max(stroke, coil_bind_pos);
        const diff_limits = Math.abs(stroke - coil_bind_pos);
        
        if (diff_limits > 0.5) { // Solo dibujar si hay una diferencia visible
            // Línea conectora
            shapes.push({
                type: 'line', x0: min_limit, x1: max_limit, y0: 0.85, y1: 0.85, xref: 'x', yref: 'paper',
                line: {color: '#2980b9', width: 1, dash: 'dot'}
            });
            // Texto con el valor
            annotations.push({
                x: (min_limit + max_limit) / 2, y: 0.85, xref: 'x', yref: 'paper',
                text: `Diff: <b>${diff_limits.toFixed(1)}</b> mm`,
                showarrow: false, font: {size: 10, color: '#2980b9'}, bgcolor: '#fff', bordercolor:'#2980b9', yshift: 0
            });
        }

        // C. ALERTAS DE EXCESO (Tu segundo pedido)
        // 1. Exceso sobre Coil Bind
        if (total_used > coil_bind_pos) {
            const excess_cb = total_used - coil_bind_pos;
            annotations.push({
                x: total_used, y: 0.5, xref: 'x', yref: 'paper',
                text: `⚠️ +${excess_cb.toFixed(1)} mm SOBRE COIL`,
                showarrow: true, arrowhead: 3, ax: 40, ay: 0,
                font: {color: 'white', size: 10, weight: 'bold'}, bgcolor: '#c0392b', borderpad: 4
            });
        }

        // 2. Exceso sobre Max Stroke
        if (total_used > stroke) {
            const excess_str = total_used - stroke;
            // Lo ponemos un poco más arriba o abajo para que no se superponga si ambos fallan
            annotations.push({
                x: total_used, y: 0.2, xref: 'x', yref: 'paper',
                text: `⚠️ +${excess_str.toFixed(1)} mm SOBRE STROKE`,
                showarrow: true, arrowhead: 3, ax: 40, ay: 0,
                font: {color: 'white', size: 10, weight: 'bold'}, bgcolor: '#e67e22', borderpad: 4
            });
        }

        // --- SHAPES (Líneas verticales) ---
        shapes.push(
            // Línea Fin de Stroke (Tope Mecánico)
            { type: 'line', x0: stroke, x1: stroke, y0: -0.5, y1: 0.5, line: {color: 'black', width: 2, dash: 'dash'} },
            // Línea Coil Bind (Tope Resorte)
            { type: 'line', x0: coil_bind_pos, x1: coil_bind_pos, y0: -0.5, y1: 0.5, line: {color: '#c0392b', width: 4} }
        );

        const layout = {
            title: {text: 'Uso de Stroke & Márgenes', font: {size: 11}, pad:{t:0, b:0, l:0, r:0}},
            barmode: 'stack',
            height: 160, // Un poco más alto para las nuevas etiquetas
            margin: {l: 10, r: 10, t: 40, b: 30},
            showlegend: false,
            paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
            xaxis: {
                title: 'Desplazamiento (mm)', titlefont: {size:10},
                range: [0, Math.max(stroke, coil_bind_pos, total_used) + 15], // Expandir rango si hay exceso
                zeroline: true, showgrid: true
            },
            yaxis: { fixedrange: true, showticklabels: false },
            shapes: shapes,
            annotations: annotations
        };

        Plotly.newPlot(elementId, data, layout, {displayModeBar: false});
    }

    // --- GENERADORES HTML REPORTES (CORREGIDO PARA TEXTO NEGRO) ---
    function generarReporteTexto(res, titulo, color, vizId) {
        const pct_sag = (res.sag_mm / res.stroke_mm) * 100;
        const pct_total = (res.travel_total_mm / res.stroke_mm) * 100;

        return `
        <div class="st-card" style="border-top: 4px solid ${color};">
            <h3 style="color:${color}; text-align:center; border-bottom:1px solid #ddd;">${titulo}</h3>
            
            <div style="font-family: 'Segoe UI', sans-serif; font-size:0.85rem; color:#333;">
                <div style="text-align:center; font-weight:bold; margin-bottom:8px; color:#444;">ESPECIFICACIÓN VALVING (Dyno)</div>
                <table class="st-table" style="margin-bottom: 10px;">
                    <tr><td style="font-weight:600;">Coef. Rebound:</td><td style="text-align:right; font-weight:bold;">${res.c_reb.toFixed(1)} Ns/m</td></tr>
                    <tr><td style="font-weight:600;">Coef. Comp:</td><td style="text-align:right; font-weight:bold;">${res.c_comp.toFixed(1)} Ns/m</td></tr>
                </table>
                
                <div style="background:#f1f3f4; padding:8px; border-radius:4px; font-size:0.8rem; color:#555; text-align:center; border:1px solid #e0e0e0;">
                   LS: R ${ (res.c_reb*0.051).toFixed(0) } / C ${ (res.c_comp*0.051).toFixed(0) } | HS: R ${ (res.c_reb*0.254).toFixed(0) } / C ${ (res.c_comp*0.254).toFixed(0) }
                </div>
                
                <hr style="border:0; border-top:1px solid #eee; margin:15px 0;">
                
                <div style="text-align:center; font-weight:bold; margin-bottom:8px; color:#444;">DINÁMICA (Carga Extrema)</div>
                <table class="st-table">
                    <tr><td>Frec. Natural:</td><td style="text-align:right; color:${color}; font-weight:bold;">${res.fn.toFixed(2)} Hz</td></tr>
                    <tr><td>Spring Rate (W):</td><td style="text-align:right">${(res.kw_spring/1000).toFixed(2)} N/mm</td></tr>
                    
                    <tr style="background-color:#fffde7;"><td>Sag Natural:</td><td style="text-align:right; color:#555;">${res.sag_mm.toFixed(1)} mm</td></tr>
                    <tr style="background-color:#fffde7;"><td>% Stroke (Sag):</td><td style="text-align:right; font-weight:bold; color:#e67e22;">${pct_sag.toFixed(1)}%</td></tr>
                    <tr style="background-color:#fffde7;"><td>Recorrido G:</td><td style="text-align:right; color:#555;">${res.travel_g_mm.toFixed(1)} mm</td></tr>
                    <tr style="border-top:2px solid #ddd;"><td><b>RECORRIDO TOTAL:</b></td><td style="text-align:right; font-weight:bold; font-size:1.1em;">${res.travel_total_mm.toFixed(1)} mm</td></tr>
                    <tr><td>% Stroke (TOTAL):</td><td style="text-align:right; font-weight:bold;">${pct_total.toFixed(0)}%</td></tr>
                    <tr><td>Margen Coil Bind:</td><td style="text-align:right; font-weight:bold; color:${res.margen_coil<5?'#c0392b':'#27ae60'}">${res.margen_coil.toFixed(1)} mm</td></tr>
                </table>

                <div style="margin-top:15px; background:#e8f6f3; padding:12px; border-radius:6px; border:1px solid #d4efdf;">
                    <div style="text-align:center; font-weight:bold; color:#1da253; margin-bottom:5px; font-size:1.1em;">EFICIENCIA GEOMÉTRICA</div>
                    
                    <div style="display:flex; justify-content:space-between; font-size:0.9em; margin-bottom:8px; border-bottom:1px dashed #badccc; padding-bottom:5px;">
                         <span>Pushrod-Rocker:</span>
                         <span style="font-weight:bold;">${(res.eff_pushrod*100).toFixed(1)}%</span>
                    </div>
                    <div style="display:flex; justify-content:space-between; font-size:0.9em; margin-bottom:8px; border-bottom:1px dashed #badccc; padding-bottom:5px;">
                         <span>Damper-Rocker:</span>
                         <span style="font-weight:bold;">${(res.eff_damper*100).toFixed(1)}%</span>
                    </div>

                    <div style="text-align:center; font-size:1.4em; font-weight:900; color:#000; margin-bottom:10px;">
                        TOTAL: ${(res.eff_total*100).toFixed(1)}%
                    </div>
                    
                    <table style="width:100%; font-size:0.9em; border-top:1px solid #badccc; padding-top:8px;">
                        <tr>
                            <td style="color:#222; font-weight:600;">F. Pushrod Axial:</td>
                            <td style="text-align:right; font-weight:800; color:#000; font-size:1.1em;">${res.f_pushrod_axial.toFixed(0)} N</td>
                        </tr>
                        <tr>
                            <td style="color:#333; padding-left:10px;">➜ Al Resorte (Útil):</td>
                            <td style="text-align:right; font-weight:bold; color:#1da253;">${res.f_effective.toFixed(0)} N</td>
                        </tr>
                        <tr>
                            <td style="color:#333; padding-left:10px;">➜ Al Perno (Pérdida):</td>
                            <td style="text-align:right; font-weight:bold; color:#c0392b;">${res.f_misalign.toFixed(0)} N</td>
                        </tr>
                    </table>
                </div>

                <div id="${vizId}" style="width:100%; height:130px; margin-top:15px; border:1px solid #eee; background:#fff;"></div>

            </div>
        </div>`;
    }

    function generarReporteBalance(b) {
        return `
        <div class="st-card" style="border-top: 4px solid #8e44ad;">
            <h3 style="color:#8e44ad; text-align:center; border-bottom:1px solid #ddd;">CÁLCULO DE BALANCE (Rigidez Rolido)</h3>
            <div style="display:flex; gap:20px; font-family:'Segoe UI', sans-serif; font-size:0.85rem; color:#333;">
                <div style="flex:1; border-right:1px solid #eee; padding-right:10px;">
                    <div style="color:#2980b9; font-weight:bold; text-align:center;">DELANTERA</div>
                    <div style="text-align:center; font-size:1.1em; margin-bottom:5px; font-weight:bold;">${b.kroll_f.toFixed(0)} Nm/rad</div>
                    <div style="color:#666; font-size:0.8em; text-align:center;">Resortes: ${b.k_spr_f.toFixed(0)}</div>
                    <div style="color:#666; font-size:0.8em; text-align:center;">ARB: ${b.k_arb_f.toFixed(0)}</div>
                </div>
                <div style="flex:1; padding-left:10px;">
                    <div style="color:#c0392b; font-weight:bold; text-align:center;">TRASERA</div>
                    <div style="text-align:center; font-size:1.1em; margin-bottom:5px; font-weight:bold;">${b.kroll_r.toFixed(0)} Nm/rad</div>
                    <div style="color:#666; font-size:0.8em; text-align:center;">Resortes: ${b.k_spr_r.toFixed(0)}</div>
                    <div style="color:#666; font-size:0.8em; text-align:center;">ARB: ${b.k_arb_r.toFixed(0)}</div>
                </div>
            </div>
            <div style="margin-top:15px; padding:10px; background:#f8f9fa; border-radius:4px; text-align:center; border:1px solid #e9ecef; color:#333;">
                Rigidez Total Chasis: <b>${b.kroll_tot.toFixed(0)} Nm/rad</b><br>
                Distribución Delantera: <b>${(b.dist_f*100).toFixed(2)}%</b><br>
                <span style="font-weight:bold; color:#8e44ad; font-size:1.1em;">${b.diag}</span>
            </div>
        </div>`;
    }

    // --- SOLVER RK4 ---
    function runRK4(res, roadFunc, tEnd) {
        const ms = res.ms, mu = res.mu;
        const kw = res.kw_spring, kt = res.k_tire;
        const mr = res.mr_damper;
        const c_reb = res.c_reb * mr**2; 
        const c_comp = res.c_comp * mr**2;
        
        let t = 0, dt = 0.002;
        let y = [0,0,0,0]; // xs, vs, xu, vu
        
        const t_arr = [], damp_arr = [], road_arr = [], xu_arr = [];

        const deriv = (t, state) => {
            let xs=state[0], vs=state[1], xu=state[2], vu=state[3];
            let r = roadFunc(t);
            let v_rel = vs - vu;
            let c_inst = v_rel > 0 ? c_reb : c_comp;
            
            let vs_dot = (-kw*(xs-xu) - c_inst*(vs-vu))/ms;
            let vu_dot = (kw*(xs-xu) + c_inst*(vs-vu) - kt*(xu-r))/mu;
            return [vs, vs_dot, vu, vu_dot];
        };

        while(t <= tEnd) {
            t_arr.push(t);
            damp_arr.push((y[0]-y[2])*mr*1000); 
            road_arr.push(roadFunc(t)*mr*1000); 
            xu_arr.push(y[2]); 
            
            // Paso RK4
            let k1 = deriv(t, y);
            let k2 = deriv(t + dt/2, y.map((v,i) => v + k1[i]*dt/2));
            let k3 = deriv(t + dt/2, y.map((v,i) => v + k2[i]*dt/2));
            let k4 = deriv(t + dt, y.map((v,i) => v + k3[i]*dt));

            y = y.map((v,i) => v + (dt/6)*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));
            t += dt;
        }
        return { t: t_arr, damp: damp_arr, road_ref: road_arr, xu: xu_arr };
    }

    // --- PLOTTING (CONFIGURADO PARA TEXTO NEGRO) ---

    function plotFvComparativo(f, r) {
        const vel = [], f_reb = [], f_comp = [], r_reb = [], r_comp = [];
        for(let v=0; v<=0.3; v+=0.01) {
            vel.push(v*1000);
            f_reb.push(f.c_reb*v); f_comp.push(-f.c_comp*v);
            r_reb.push(r.c_reb*v); r_comp.push(-r.c_comp*v);
        }
        Plotly.newPlot('chart-fv', [
            {x:vel, y:f_reb, name:'Del Reb', line:{color:'#2980b9', width:3}},
            {x:vel, y:f_comp, name:'Del Comp', line:{color:'#2980b9', dash:'dot', width:3}},
            {x:vel, y:r_reb, name:'Tras Reb', line:{color:'#c0392b', width:3}},
            {x:vel, y:r_comp, name:'Tras Comp', line:{color:'#c0392b', dash:'dot', width:3}}
        ], {
            title:'Curvas F vs V (Comparativa)', 
            plot_bgcolor: '#ffffff', paper_bgcolor: '#ffffff', font: { color: '#000000' },
            xaxis:{title:'Velocidad Vástago (mm/s)', gridcolor:'#eee'}, yaxis:{title:'Fuerza (N)', gridcolor:'#eee'},
            margin:{t:40,b:40,l:50,r:10}, legend:{orientation:"h", y:1.1}
        }, {displayModeBar: false});
    }

    function plotTransitorio(sim_b, sim_p, divId, title, color) {
        Plotly.newPlot(divId, [
            {x:sim_b.t, y:sim_b.damp, name:'Bache', line:{color:color}},
            {x:sim_p.t, y:sim_p.damp, name:'Piano', line:{color:'#9b59b6', width:1}}
        ], {
            title: title, 
            plot_bgcolor: '#ffffff', paper_bgcolor: '#ffffff', font: { color: '#000000' },
            xaxis:{title:'T (s)', gridcolor:'#eee'}, yaxis:{title:'Damper (mm)', gridcolor:'#eee'}, 
            margin:{t:30,b:30,l:40,r:10}, showlegend:true, legend:{orientation:"h", y:1.1}
        }, {displayModeBar: false});
    }

    function plotGrip(sim, res, divId, title) {
        const kt = res.k_tire;
        const f_stat = res.f_total; 
        const static_def_mm = (f_stat/kt)*1000;
        
        const grip_mm = sim.t.map((t, i) => {
            let road_real_m = sim.road_ref[i] / res.mr_damper / 1000; 
            let def_dyn_m = road_real_m - sim.xu[i];
            return static_def_mm + (def_dyn_m * 1000);
        });

        Plotly.newPlot(divId, [
            {x:sim.t, y:grip_mm, name:'Grip', fill:'tozeroy', line:{color:'green', width:1}}
        ], {
            title: title, 
            plot_bgcolor: '#ffffff', paper_bgcolor: '#ffffff', font: { color: '#000000' },
            shapes: [{type:'line', x0:0, x1:1, y0:0, y1:0, line:{color:'red', width:2}}],
            yaxis:{title:'Compresión (mm)', range:[-2, Math.max(...grip_mm)+5], gridcolor:'#eee'}, 
            xaxis:{gridcolor:'#eee'},
            margin:{t:30,b:30,l:40,r:10}
        }, {displayModeBar: false});
    }


    function plotPhotoStyle(sim, res, divId, title) {
         const kt = res.k_tire;
         const f_stat = res.f_total; 
         const static_def_mm = (f_stat/kt)*1000;
         
         const grip_mm = sim.t.map((t, i) => {
             let road_real_m = sim.road_ref[i] / res.mr_damper / 1000; 
             let def_dyn_m = road_real_m - sim.xu[i];
             return static_def_mm + (def_dyn_m * 1000);
         });

         const min_grip = Math.min(...grip_mm);
         
         const layout = {
             title: title,
             plot_bgcolor: '#ffffff', paper_bgcolor: '#ffffff', font: { color: '#000000' },
             xaxis:{title:'T (s)', gridcolor:'#eee'}, 
             yaxis:{title:'Carga (mm)', gridcolor:'#eee'},
             margin:{t:30,b:30,l:40,r:10},
             shapes: [
                {type:'line', x0:0, x1:1, y0:static_def_mm, y1:static_def_mm, line:{color:'gray', dash:'dot'}},
                {type:'line', x0:0, x1:1, y0:0, y1:0, line:{color:'red', width:2}}
             ]
         };

         if(min_grip < 0) {
             layout.annotations = [{
                 x: 0.5, y: 0.5, xref: 'paper', yref: 'paper',
                 text: 'PERDIDA CONTACTO', showarrow: false,
                 font: {color:'white', size:12, weight:'bold'}, bgcolor:'red', opacity: 0.8
             }];
         }

         Plotly.newPlot(divId, [
             {x:sim.t, y:grip_mm, name:'Carga', line:{color:'#e67e22', width:2}}
         ], layout, {displayModeBar: false});
    }

    // Inicialización automática
    switchTab('front'); 
    renderInputs(); 
    setTimeout(calculateAndPlot, 800);
</script>
</body>

</html>
